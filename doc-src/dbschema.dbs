<?xml version="1.0" encoding="UTF-8" ?>
<project name="PostgreSQL" id="PostgreSQL-1fef" database="PostgreSQL" >
	<schema name="core" >
		<udt name="interlink_type" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('HASH','USERNAME');]]></udt_script>
		</udt>
		<udt name="osm_type" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('N','W','R');]]></udt_script>
		</udt>
		<udt name="user_account_provider" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('GOOGLE','LOCAL');]]></udt_script>
		</udt>
		<udt name="user_account_role" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('ROOT','ADMIN','SUPER_USER','USER');]]></udt_script>
		</udt>
		<udt name="wiretap_status" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('READY','WAITING','DEACTIVATED');]]></udt_script>
		</udt>
		<table name="confirmation_token" row_count="0" spec="" >
			<column name="id" type="integer" length="32" jt="4" mandatory="y" >
				<defo><![CDATA[nextval('core.confirmation_token_id_seq'::regclass)]]></defo>
			</column>
			<column name="value" type="varchar" jt="12" mandatory="y" />
			<column name="created_at" type="timestamp" jt="93" >
				<defo><![CDATA[CURRENT_TIMESTAMP]]></defo>
			</column>
			<column name="user_account_id" type="integer" length="32" jt="4" mandatory="y" />
			<index name="confirmation_token_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
			<index name="confirmation_token_value_key" unique="UNIQUE_KEY" >
				<column name="value" />
			</index>
			<fk name="confirmation_token_user_account_id_fkey" to_schema="core" to_table="user_account" options="" >
				<fk_column name="user_account_id" pk="id" />
			</fk>
		</table>
		<table name="locality" row_count="0" spec="" >
			<column name="id" type="integer" length="32" jt="4" mandatory="y" >
				<defo><![CDATA[nextval('core.locality_id_seq'::regclass)]]></defo>
			</column>
			<column name="osm_type" type="osm_type" jt="12" mandatory="y" />
			<column name="osm_id" type="bigint" length="64" jt="-5" mandatory="y" />
			<column name="display_name" type="varchar" jt="12" />
			<column name="rank_address" type="integer" length="32" jt="4" mandatory="y" />
			<column name="latitude" type="double precision" jt="3" mandatory="y" />
			<column name="longitude" type="double precision" jt="3" mandatory="y" />
			<column name="min_latitude" type="double precision" jt="3" mandatory="y" />
			<column name="max_latitude" type="double precision" jt="3" mandatory="y" />
			<column name="min_longitude" type="double precision" jt="3" mandatory="y" />
			<column name="max_longitude" type="double precision" jt="3" mandatory="y" />
			<index name="locality_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
			<index name="uq_locality_osm" unique="UNIQUE_KEY" >
				<column name="osm_type" />
				<column name="osm_id" />
			</index>
		</table>
		<table name="mapping_info" row_count="0" spec="" >
			<column name="id" type="integer" length="32" jt="4" mandatory="y" >
				<defo><![CDATA[nextval('core.mapping_info_id_seq'::regclass)]]></defo>
			</column>
			<column name="wiretap_id" type="integer" length="32" jt="4" mandatory="y" />
			<column name="title" type="varchar" length="255" jt="12" />
			<column name="member_count" type="integer" length="32" jt="4" />
			<column name="username" type="varchar" length="50" jt="12" />
			<column name="description" type="varchar" jt="12" />
			<column name="is_channel" type="boolean" jt="16" />
			<index name="mapping_info_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
			<index name="mapping_info_wiretap_id_key" unique="UNIQUE_KEY" >
				<column name="wiretap_id" />
			</index>
			<fk name="mapping_info_wiretap_id_fkey" to_schema="core" to_table="wiretap" delete_action="cascade" options="" >
				<fk_column name="wiretap_id" pk="id" />
			</fk>
		</table>
		<table name="user_account" row_count="0" spec="" >
			<column name="id" type="integer" length="32" jt="4" mandatory="y" >
				<defo><![CDATA[nextval('core.user_account_id_seq'::regclass)]]></defo>
			</column>
			<column name="provider" type="user_account_provider" jt="12" mandatory="y" />
			<column name="name" type="varchar" length="255" jt="12" />
			<column name="profile_photo" type="varchar" length="255" jt="12" />
			<column name="email" type="varchar" length="320" jt="12" mandatory="y" />
			<column name="verified" type="boolean" jt="16" />
			<column name="password" type="varchar" length="255" jt="12" />
			<column name="role" type="user_account_role" jt="12" mandatory="y" />
			<column name="created_at" type="timestamp" jt="93" >
				<defo><![CDATA[CURRENT_TIMESTAMP]]></defo>
			</column>
			<index name="user_account_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
		</table>
		<table name="wiretap" row_count="0" spec="" >
			<column name="id" type="integer" length="32" jt="4" mandatory="y" >
				<defo><![CDATA[nextval('core.wiretap_id_seq'::regclass)]]></defo>
			</column>
			<column name="user_account_id" type="integer" length="32" jt="4" mandatory="y" />
			<column name="locality_id" type="integer" length="32" jt="4" mandatory="y" />
			<column name="telegram_supergroup_id" type="bigint" length="64" jt="-5" />
			<column name="telegram_supergroup_api_id" type="integer" length="32" jt="4" />
			<column name="primary_interlink" type="varchar" length="255" jt="12" mandatory="y" />
			<column name="status" type="wiretap_status" jt="12" mandatory="y" />
			<column name="created_at" type="timestamp" jt="93" >
				<defo><![CDATA[CURRENT_TIMESTAMP]]></defo>
			</column>
			<index name="wiretap_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
			<index name="uq_wiretap_t_supergroup" unique="UNIQUE_KEY" >
				<column name="telegram_supergroup_id" />
				<column name="telegram_supergroup_api_id" />
			</index>
			<fk name="wiretap_locality_id_fkey" to_schema="core" to_table="locality" options="" >
				<fk_column name="locality_id" pk="id" />
			</fk>
			<fk name="wiretap_telegram_supergroup_id_telegram_supergroup_api_id_fkey" to_schema="telegram" to_table="supergroup" options="" >
				<fk_column name="telegram_supergroup_id" pk="id" />
				<fk_column name="telegram_supergroup_api_id" pk="api_id" />
			</fk>
			<fk name="wiretap_user_account_id_fkey" to_schema="core" to_table="user_account" options="" >
				<fk_column name="user_account_id" pk="id" />
			</fk>
		</table>
		<sequence name="confirmation_token_id_seq" options="AS integer START WITH 1 INCREMENT BY 1" />
		<sequence name="locality_id_seq" options="AS integer START WITH 1 INCREMENT BY 1" />
		<sequence name="mapping_info_id_seq" options="AS integer START WITH 1 INCREMENT BY 1" />
		<sequence name="user_account_id_seq" options="AS integer START WITH 1 INCREMENT BY 1" />
		<sequence name="wiretap_id_seq" options="AS integer START WITH 1 INCREMENT BY 1" />
	</schema>
	<schema name="information_schema" >
		<udt name="cardinal_number" udt_java_type="4" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE DOMAIN ${name} integer CONSTRAINT cardinal_number_domain_check CHECK (VALUE >= 0)]]></udt_script>
		</udt>
		<udt name="character_data" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE DOMAIN ${name} character varying ]]></udt_script>
		</udt>
		<udt name="sql_identifier" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE DOMAIN ${name} name ]]></udt_script>
		</udt>
		<udt name="time_stamp" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE DOMAIN ${name} timestamp(2) with time zone DEFAULT CURRENT_TIMESTAMP(2) ]]></udt_script>
		</udt>
		<udt name="yes_or_no" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE DOMAIN ${name} character varying(3) CONSTRAINT yes_or_no_check CHECK (VALUE::text = ANY (ARRAY['YES'::character varying, 'NO'::character varying]::text[]))]]></udt_script>
		</udt>
		<table name="sql_features" row_count="755" spec="" >
			<column name="feature_id" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="feature_name" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="sub_feature_id" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="sub_feature_name" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="is_supported" type="yes_or_no" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="is_verified_by" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="comments" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
		</table>
		<table name="sql_implementation_info" row_count="12" spec="" >
			<column name="implementation_info_id" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="implementation_info_name" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="integer_value" type="cardinal_number" jt="4" />
			<column name="character_value" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="comments" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
		</table>
		<table name="sql_parts" row_count="11" spec="" >
			<column name="feature_id" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="feature_name" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="is_supported" type="yes_or_no" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="is_verified_by" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="comments" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
		</table>
		<table name="sql_sizing" row_count="23" spec="" >
			<column name="sizing_id" type="cardinal_number" jt="4" />
			<column name="sizing_name" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
			<column name="supported_value" type="cardinal_number" jt="4" />
			<column name="comments" type="character_data" jt="12" >
				<column_options><![CDATA[COLLATE C]]></column_options>
			</column>
		</table>
		<view name="_pg_foreign_data_wrappers" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT w.oid,
    w.fdwowner,
    w.fdwoptions,
    (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
    (w.fdwname)::information_schema.sql_identifier AS foreign_data_wrapper_name,
    (u.rolname)::information_schema.sql_identifier AS authorization_identifier,
    ('c'::character varying)::information_schema.character_data AS foreign_data_wrapper_language
   FROM pg_foreign_data_wrapper w,
    pg_authid u
  WHERE ((u.oid = w.fdwowner) AND (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text)))]]></view_script>
			<column name="oid" type="oid" />
			<column name="fdwowner" type="oid" />
			<column name="fdwoptions" type="text[]" />
			<column name="foreign_data_wrapper_catalog" type="sql_identifier" />
			<column name="foreign_data_wrapper_name" type="sql_identifier" />
			<column name="authorization_identifier" type="sql_identifier" />
			<column name="foreign_data_wrapper_language" type="character_data" />
		</view>
		<view name="_pg_foreign_servers" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT s.oid,
    s.srvoptions,
    (current_database())::information_schema.sql_identifier AS foreign_server_catalog,
    (s.srvname)::information_schema.sql_identifier AS foreign_server_name,
    (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
    (w.fdwname)::information_schema.sql_identifier AS foreign_data_wrapper_name,
    (s.srvtype)::information_schema.character_data AS foreign_server_type,
    (s.srvversion)::information_schema.character_data AS foreign_server_version,
    (u.rolname)::information_schema.sql_identifier AS authorization_identifier
   FROM pg_foreign_server s,
    pg_foreign_data_wrapper w,
    pg_authid u
  WHERE ((w.oid = s.srvfdw) AND (u.oid = s.srvowner) AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)))]]></view_script>
			<column name="oid" type="oid" />
			<column name="srvoptions" type="text[]" />
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
			<column name="foreign_data_wrapper_catalog" type="sql_identifier" />
			<column name="foreign_data_wrapper_name" type="sql_identifier" />
			<column name="foreign_server_type" type="character_data" />
			<column name="foreign_server_version" type="character_data" />
			<column name="authorization_identifier" type="sql_identifier" />
		</view>
		<view name="_pg_foreign_table_columns" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT n.nspname,
    c.relname,
    a.attname,
    a.attfdwoptions
   FROM pg_foreign_table t,
    pg_authid u,
    pg_namespace n,
    pg_class c,
    pg_attribute a
  WHERE ((u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f'::"char") AND (a.attrelid = c.oid) AND (a.attnum > 0))]]></view_script>
			<column name="nspname" type="name" />
			<column name="relname" type="name" />
			<column name="attname" type="name" />
			<column name="attfdwoptions" type="text[]" />
		</view>
		<view name="_pg_foreign_tables" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS foreign_table_catalog,
    (n.nspname)::information_schema.sql_identifier AS foreign_table_schema,
    (c.relname)::information_schema.sql_identifier AS foreign_table_name,
    t.ftoptions,
    (current_database())::information_schema.sql_identifier AS foreign_server_catalog,
    (s.srvname)::information_schema.sql_identifier AS foreign_server_name,
    (u.rolname)::information_schema.sql_identifier AS authorization_identifier
   FROM pg_foreign_table t,
    pg_foreign_server s,
    pg_foreign_data_wrapper w,
    pg_authid u,
    pg_namespace n,
    pg_class c
  WHERE ((w.oid = s.srvfdw) AND (u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f'::"char") AND (s.oid = t.ftserver))]]></view_script>
			<column name="foreign_table_catalog" type="sql_identifier" />
			<column name="foreign_table_schema" type="sql_identifier" />
			<column name="foreign_table_name" type="sql_identifier" />
			<column name="ftoptions" type="text[]" />
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
			<column name="authorization_identifier" type="sql_identifier" />
		</view>
		<view name="_pg_user_mappings" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT um.oid,
    um.umoptions,
    um.umuser,
    (COALESCE(u.rolname, 'PUBLIC'::name))::information_schema.sql_identifier AS authorization_identifier,
    s.foreign_server_catalog,
    s.foreign_server_name,
    s.authorization_identifier AS srvowner
   FROM (pg_user_mapping um
     LEFT JOIN pg_authid u ON ((u.oid = um.umuser))),
    information_schema._pg_foreign_servers s
  WHERE (s.oid = um.umserver)
 SELECT um.oid,
    um.umoptions,
    um.umuser,
    (COALESCE(u.rolname, 'PUBLIC'::name))::information_schema.sql_identifier AS authorization_identifier,
    s.foreign_server_catalog,
    s.foreign_server_name,
    s.authorization_identifier AS srvowner
   FROM (pg_user_mapping um
     LEFT JOIN pg_authid u ON ((u.oid = um.umuser))),
    information_schema._pg_foreign_servers s
  WHERE (s.oid = um.umserver)]]></view_script>
			<column name="oid" type="oid" />
			<column name="umoptions" type="text[]" />
			<column name="umuser" type="oid" />
			<column name="authorization_identifier" type="sql_identifier" />
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
			<column name="srvowner" type="sql_identifier" />
		</view>
		<view name="administrable_role_authorizations" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT grantee,
    role_name,
    is_grantable
   FROM information_schema.applicable_roles
  WHERE ((is_grantable)::text = 'YES'::text)
 SELECT grantee,
    role_name,
    is_grantable
   FROM information_schema.applicable_roles
  WHERE ((is_grantable)::text = 'YES'::text)]]></view_script>
			<column name="grantee" type="sql_identifier" />
			<column name="role_name" type="sql_identifier" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="applicable_roles" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (a.rolname)::information_schema.sql_identifier AS grantee,
    (b.rolname)::information_schema.sql_identifier AS role_name,
    (
        CASE
            WHEN m.admin_option THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ((( SELECT pg_auth_members.member,
            pg_auth_members.roleid,
            pg_auth_members.admin_option
           FROM pg_auth_members
        UNION
         SELECT pg_database.datdba,
            pg_authid.oid,
            false
           FROM pg_database,
            pg_authid
          WHERE ((pg_database.datname = current_database()) AND (pg_authid.rolname = 'pg_database_owner'::name))) m
     JOIN pg_authid a ON ((m.member = a.oid)))
     JOIN pg_authid b ON ((m.roleid = b.oid)))
  WHERE pg_has_role(a.oid, 'USAGE'::text)]]></view_script>
			<column name="grantee" type="sql_identifier" />
			<column name="role_name" type="sql_identifier" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="attributes" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nc.nspname)::information_schema.sql_identifier AS udt_schema,
    (c.relname)::information_schema.sql_identifier AS udt_name,
    (a.attname)::information_schema.sql_identifier AS attribute_name,
    (a.attnum)::information_schema.cardinal_number AS ordinal_position,
    (pg_get_expr(ad.adbin, ad.adrelid))::information_schema.character_data AS attribute_default,
    (
        CASE
            WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text
            ELSE 'YES'::text
        END)::information_schema.yes_or_no AS is_nullable,
    (
        CASE
            WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
            WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer)
            ELSE 'USER-DEFINED'::text
        END)::information_schema.character_data AS data_type,
    (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_maximum_length,
    (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (
        CASE
            WHEN (nco.nspname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS collation_catalog,
    (nco.nspname)::information_schema.sql_identifier AS collation_schema,
    (co.collname)::information_schema.sql_identifier AS collation_name,
    (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision,
    (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix,
    (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_scale,
    (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS datetime_precision,
    (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (current_database())::information_schema.sql_identifier AS attribute_udt_catalog,
    (nt.nspname)::information_schema.sql_identifier AS attribute_udt_schema,
    (t.typname)::information_schema.sql_identifier AS attribute_udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    (a.attnum)::information_schema.sql_identifier AS dtd_identifier,
    ('NO'::character varying)::information_schema.yes_or_no AS is_derived_reference_attribute
   FROM ((((pg_attribute a
     LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
     JOIN (pg_class c
     JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
     JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
     LEFT JOIN (pg_collation co
     JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = 'c'::"char") AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_type_privilege(c.reltype, 'USAGE'::text)))]]></view_script>
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="attribute_name" type="sql_identifier" />
			<column name="ordinal_position" type="cardinal_number" />
			<column name="attribute_default" type="character_data" />
			<column name="is_nullable" type="yes_or_no" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="attribute_udt_catalog" type="sql_identifier" />
			<column name="attribute_udt_schema" type="sql_identifier" />
			<column name="attribute_udt_name" type="sql_identifier" />
			<column name="scope_catalog" type="sql_identifier" />
			<column name="scope_schema" type="sql_identifier" />
			<column name="scope_name" type="sql_identifier" />
			<column name="maximum_cardinality" type="cardinal_number" />
			<column name="dtd_identifier" type="sql_identifier" />
			<column name="is_derived_reference_attribute" type="yes_or_no" />
		</view>
		<view name="character_sets" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (getdatabaseencoding())::information_schema.sql_identifier AS character_set_name,
    (
        CASE
            WHEN (getdatabaseencoding() = 'UTF8'::name) THEN 'UCS'::name
            ELSE getdatabaseencoding()
        END)::information_schema.sql_identifier AS character_repertoire,
    (getdatabaseencoding())::information_schema.sql_identifier AS form_of_use,
    (current_database())::information_schema.sql_identifier AS default_collate_catalog,
    (nc.nspname)::information_schema.sql_identifier AS default_collate_schema,
    (c.collname)::information_schema.sql_identifier AS default_collate_name
   FROM (pg_database d
     LEFT JOIN (pg_collation c
     JOIN pg_namespace nc ON ((c.collnamespace = nc.oid))) ON (((d.datcollate = c.collcollate) AND (d.datctype = c.collctype))))
  WHERE (d.datname = current_database())
  ORDER BY (char_length((c.collname)::text)) DESC, c.collname
 LIMIT 1]]></view_script>
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="character_repertoire" type="sql_identifier" />
			<column name="form_of_use" type="sql_identifier" />
			<column name="default_collate_catalog" type="sql_identifier" />
			<column name="default_collate_schema" type="sql_identifier" />
			<column name="default_collate_name" type="sql_identifier" />
		</view>
		<view name="check_constraint_routine_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (nc.nspname)::information_schema.sql_identifier AS constraint_schema,
    (c.conname)::information_schema.sql_identifier AS constraint_name,
    (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name
   FROM pg_namespace nc,
    pg_constraint c,
    pg_depend d,
    pg_proc p,
    pg_namespace np
  WHERE ((nc.oid = c.connamespace) AND (c.contype = 'c'::"char") AND (c.oid = d.objid) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.refobjid = p.oid) AND (d.refclassid = ('pg_proc'::regclass)::oid) AND (p.pronamespace = np.oid) AND pg_has_role(p.proowner, 'USAGE'::text))]]></view_script>
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
		</view>
		<view name="check_constraints" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (rs.nspname)::information_schema.sql_identifier AS constraint_schema,
    (con.conname)::information_schema.sql_identifier AS constraint_name,
    (SUBSTRING(pg_get_constraintdef(con.oid) FROM 7))::information_schema.character_data AS check_clause
   FROM (((pg_constraint con
     LEFT JOIN pg_namespace rs ON ((rs.oid = con.connamespace)))
     LEFT JOIN pg_class c ON ((c.oid = con.conrelid)))
     LEFT JOIN pg_type t ON ((t.oid = con.contypid)))
  WHERE (pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text) AND (con.contype = 'c'::"char"))
UNION
 SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (n.nspname)::information_schema.sql_identifier AS constraint_schema,
    (((((((n.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text))::information_schema.sql_identifier AS constraint_name,
    (((a.attname)::text || ' IS NOT NULL'::text))::information_schema.character_data AS check_clause
   FROM pg_namespace n,
    pg_class r,
    pg_attribute a
  WHERE ((n.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (a.attnum > 0) AND (NOT a.attisdropped) AND a.attnotnull AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND pg_has_role(r.relowner, 'USAGE'::text))]]></view_script>
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
			<column name="check_clause" type="character_data" />
		</view>
		<view name="collation_character_set_applicability" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS collation_catalog,
    (nc.nspname)::information_schema.sql_identifier AS collation_schema,
    (c.collname)::information_schema.sql_identifier AS collation_name,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (getdatabaseencoding())::information_schema.sql_identifier AS character_set_name
   FROM pg_collation c,
    pg_namespace nc
  WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])))]]></view_script>
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
		</view>
		<view name="collations" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS collation_catalog,
    (nc.nspname)::information_schema.sql_identifier AS collation_schema,
    (c.collname)::information_schema.sql_identifier AS collation_name,
    ('NO PAD'::character varying)::information_schema.character_data AS pad_attribute
   FROM pg_collation c,
    pg_namespace nc
  WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])))]]></view_script>
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="pad_attribute" type="character_data" />
		</view>
		<view name="column_column_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS table_catalog,
    (n.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (ac.attname)::information_schema.sql_identifier AS column_name,
    (ad.attname)::information_schema.sql_identifier AS dependent_column
   FROM pg_namespace n,
    pg_class c,
    pg_depend d,
    pg_attribute ac,
    pg_attribute ad,
    pg_attrdef atd
  WHERE ((n.oid = c.relnamespace) AND (c.oid = ac.attrelid) AND (c.oid = ad.attrelid) AND (ac.attnum <> ad.attnum) AND (ad.attrelid = atd.adrelid) AND (ad.attnum = atd.adnum) AND (d.classid = ('pg_attrdef'::regclass)::oid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.objid = atd.oid) AND (d.refobjid = ac.attrelid) AND (d.refobjsubid = ac.attnum) AND (ad.attgenerated <> ''::"char") AND pg_has_role(c.relowner, 'USAGE'::text))]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="dependent_column" type="sql_identifier" />
		</view>
		<view name="column_domain_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS domain_catalog,
    (nt.nspname)::information_schema.sql_identifier AS domain_schema,
    (t.typname)::information_schema.sql_identifier AS domain_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (a.attname)::information_schema.sql_identifier AS column_name
   FROM pg_type t,
    pg_namespace nt,
    pg_class c,
    pg_namespace nc,
    pg_attribute a
  WHERE ((t.typnamespace = nt.oid) AND (c.relnamespace = nc.oid) AND (a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (t.typtype = 'd'::"char") AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (a.attnum > 0) AND (NOT a.attisdropped) AND pg_has_role(t.typowner, 'USAGE'::text))]]></view_script>
			<column name="domain_catalog" type="sql_identifier" />
			<column name="domain_schema" type="sql_identifier" />
			<column name="domain_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
		</view>
		<view name="column_options" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nspname)::information_schema.sql_identifier AS table_schema,
    (relname)::information_schema.sql_identifier AS table_name,
    (attname)::information_schema.sql_identifier AS column_name,
    ((pg_options_to_table(attfdwoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(attfdwoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_table_columns c
 SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nspname)::information_schema.sql_identifier AS table_schema,
    (relname)::information_schema.sql_identifier AS table_name,
    (attname)::information_schema.sql_identifier AS column_name,
    ((pg_options_to_table(attfdwoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(attfdwoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_table_columns c]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="option_name" type="sql_identifier" />
			<column name="option_value" type="character_data" />
		</view>
		<view name="column_privileges" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (x.relname)::information_schema.sql_identifier AS table_name,
    (x.attname)::information_schema.sql_identifier AS column_name,
    (x.prtype)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(x.grantee, x.relowner, 'USAGE'::text) OR x.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pr_c.grantor,
            pr_c.grantee,
            a.attname,
            pr_c.relname,
            pr_c.relnamespace,
            pr_c.prtype,
            pr_c.grantable,
            pr_c.relowner
           FROM ( SELECT pg_class.oid,
                    pg_class.relname,
                    pg_class.relnamespace,
                    pg_class.relowner,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).is_grantable AS is_grantable
                   FROM pg_class
                  WHERE (pg_class.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))) pr_c(oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),
            pg_attribute a
          WHERE ((a.attrelid = pr_c.oid) AND (a.attnum > 0) AND (NOT a.attisdropped))
        UNION
         SELECT pr_a.grantor,
            pr_a.grantee,
            pr_a.attname,
            c.relname,
            c.relnamespace,
            pr_a.prtype,
            pr_a.grantable,
            c.relowner
           FROM ( SELECT a.attrelid,
                    a.attname,
                    (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantor AS grantor,
                    (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantee AS grantee,
                    (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).privilege_type AS privilege_type,
                    (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).is_grantable AS is_grantable
                   FROM (pg_attribute a
                     JOIN pg_class cc ON ((a.attrelid = cc.oid)))
                  WHERE ((a.attnum > 0) AND (NOT a.attisdropped))) pr_a(attrelid, attname, grantor, grantee, prtype, grantable),
            pg_class c
          WHERE ((pr_a.attrelid = c.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])))) x,
    pg_namespace nc,
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((x.relnamespace = nc.oid) AND (x.grantee = grantee.oid) AND (x.grantor = u_grantor.oid) AND (x.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text])) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="column_udt_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
    (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema,
    (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier AS udt_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (a.attname)::information_schema.sql_identifier AS column_name
   FROM pg_attribute a,
    pg_class c,
    pg_namespace nc,
    ((pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
     LEFT JOIN (pg_type bt
     JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid))))
  WHERE ((a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (nc.oid = c.relnamespace) AND (a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text))]]></view_script>
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
		</view>
		<view name="columns" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (a.attname)::information_schema.sql_identifier AS column_name,
    (a.attnum)::information_schema.cardinal_number AS ordinal_position,
    (
        CASE
            WHEN (a.attgenerated = ''::"char") THEN pg_get_expr(ad.adbin, ad.adrelid)
            ELSE NULL::text
        END)::information_schema.character_data AS column_default,
    (
        CASE
            WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text
            ELSE 'YES'::text
        END)::information_schema.yes_or_no AS is_nullable,
    (
        CASE
            WHEN (t.typtype = 'd'::"char") THEN
            CASE
                WHEN ((bt.typelem <> (0)::oid) AND (bt.typlen = '-1'::integer)) THEN 'ARRAY'::text
                WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer)
                ELSE 'USER-DEFINED'::text
            END
            ELSE
            CASE
                WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer)
                ELSE 'USER-DEFINED'::text
            END
        END)::information_schema.character_data AS data_type,
    (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_maximum_length,
    (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_octet_length,
    (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision,
    (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix,
    (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_scale,
    (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS datetime_precision,
    (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (
        CASE
            WHEN (nco.nspname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS collation_catalog,
    (nco.nspname)::information_schema.sql_identifier AS collation_schema,
    (co.collname)::information_schema.sql_identifier AS collation_name,
    (
        CASE
            WHEN (t.typtype = 'd'::"char") THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS domain_catalog,
    (
        CASE
            WHEN (t.typtype = 'd'::"char") THEN nt.nspname
            ELSE NULL::name
        END)::information_schema.sql_identifier AS domain_schema,
    (
        CASE
            WHEN (t.typtype = 'd'::"char") THEN t.typname
            ELSE NULL::name
        END)::information_schema.sql_identifier AS domain_name,
    (current_database())::information_schema.sql_identifier AS udt_catalog,
    (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema,
    (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier AS udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    (a.attnum)::information_schema.sql_identifier AS dtd_identifier,
    ('NO'::character varying)::information_schema.yes_or_no AS is_self_referencing,
    (
        CASE
            WHEN (a.attidentity = ANY (ARRAY['a'::"char", 'd'::"char"])) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_identity,
    (
        CASE a.attidentity
            WHEN 'a'::"char" THEN 'ALWAYS'::text
            WHEN 'd'::"char" THEN 'BY DEFAULT'::text
            ELSE NULL::text
        END)::information_schema.character_data AS identity_generation,
    (seq.seqstart)::information_schema.character_data AS identity_start,
    (seq.seqincrement)::information_schema.character_data AS identity_increment,
    (seq.seqmax)::information_schema.character_data AS identity_maximum,
    (seq.seqmin)::information_schema.character_data AS identity_minimum,
    (
        CASE
            WHEN seq.seqcycle THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS identity_cycle,
    (
        CASE
            WHEN (a.attgenerated <> ''::"char") THEN 'ALWAYS'::text
            ELSE 'NEVER'::text
        END)::information_schema.character_data AS is_generated,
    (
        CASE
            WHEN (a.attgenerated <> ''::"char") THEN pg_get_expr(ad.adbin, ad.adrelid)
            ELSE NULL::text
        END)::information_schema.character_data AS generation_expression,
    (
        CASE
            WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND pg_column_is_updatable((c.oid)::regclass, a.attnum, false))) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_updatable
   FROM ((((((pg_attribute a
     LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
     JOIN (pg_class c
     JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
     JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
     LEFT JOIN (pg_type bt
     JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid))))
     LEFT JOIN (pg_collation co
     JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
     LEFT JOIN (pg_depend dep
     JOIN pg_sequence seq ON (((dep.classid = ('pg_class'::regclass)::oid) AND (dep.objid = seq.seqrelid) AND (dep.deptype = 'i'::"char")))) ON (((dep.refclassid = ('pg_class'::regclass)::oid) AND (dep.refobjid = c.oid) AND (dep.refobjsubid = a.attnum))))
  WHERE ((NOT pg_is_other_temp_schema(nc.oid)) AND (a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="ordinal_position" type="cardinal_number" />
			<column name="column_default" type="character_data" />
			<column name="is_nullable" type="yes_or_no" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="domain_catalog" type="sql_identifier" />
			<column name="domain_schema" type="sql_identifier" />
			<column name="domain_name" type="sql_identifier" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="scope_catalog" type="sql_identifier" />
			<column name="scope_schema" type="sql_identifier" />
			<column name="scope_name" type="sql_identifier" />
			<column name="maximum_cardinality" type="cardinal_number" />
			<column name="dtd_identifier" type="sql_identifier" />
			<column name="is_self_referencing" type="yes_or_no" />
			<column name="is_identity" type="yes_or_no" />
			<column name="identity_generation" type="character_data" />
			<column name="identity_start" type="character_data" />
			<column name="identity_increment" type="character_data" />
			<column name="identity_maximum" type="character_data" />
			<column name="identity_minimum" type="character_data" />
			<column name="identity_cycle" type="yes_or_no" />
			<column name="is_generated" type="character_data" />
			<column name="generation_expression" type="character_data" />
			<column name="is_updatable" type="yes_or_no" />
		</view>
		<view name="constraint_column_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (tblschema)::information_schema.sql_identifier AS table_schema,
    (tblname)::information_schema.sql_identifier AS table_name,
    (colname)::information_schema.sql_identifier AS column_name,
    (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (cstrschema)::information_schema.sql_identifier AS constraint_schema,
    (cstrname)::information_schema.sql_identifier AS constraint_name
   FROM ( SELECT DISTINCT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_depend d,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
        UNION ALL
         SELECT nr.nspname,
            r.relname,
            r.relowner,
            a.attname,
            nc.nspname,
            c.conname
           FROM pg_namespace nr,
            pg_class r,
            pg_attribute a,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confrelid
                    ELSE c.conrelid
                END) AND (a.attnum = ANY (
                CASE c.contype
                    WHEN 'f'::"char" THEN c.confkey
                    ELSE c.conkey
                END)) AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname)
  WHERE pg_has_role(tblowner, 'USAGE'::text)]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
		</view>
		<view name="constraint_table_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nr.nspname)::information_schema.sql_identifier AS table_schema,
    (r.relname)::information_schema.sql_identifier AS table_name,
    (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (nc.nspname)::information_schema.sql_identifier AS constraint_schema,
    (c.conname)::information_schema.sql_identifier AS constraint_name
   FROM pg_constraint c,
    pg_namespace nc,
    pg_class r,
    pg_namespace nr
  WHERE ((c.connamespace = nc.oid) AND (r.relnamespace = nr.oid) AND (((c.contype = 'f'::"char") AND (c.confrelid = r.oid)) OR ((c.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (c.conrelid = r.oid))) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND pg_has_role(r.relowner, 'USAGE'::text))]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
		</view>
		<view name="data_type_privileges" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
    objschema AS object_schema,
    objname AS object_name,
    (objtype)::information_schema.character_data AS object_type,
    objdtdid AS dtd_identifier
   FROM ( SELECT attributes.udt_schema,
            attributes.udt_name,
            'USER-DEFINED TYPE'::text AS text,
            attributes.dtd_identifier
           FROM information_schema.attributes
        UNION ALL
         SELECT columns.table_schema,
            columns.table_name,
            'TABLE'::text AS text,
            columns.dtd_identifier
           FROM information_schema.columns
        UNION ALL
         SELECT domains.domain_schema,
            domains.domain_name,
            'DOMAIN'::text AS text,
            domains.dtd_identifier
           FROM information_schema.domains
        UNION ALL
         SELECT parameters.specific_schema,
            parameters.specific_name,
            'ROUTINE'::text AS text,
            parameters.dtd_identifier
           FROM information_schema.parameters
        UNION ALL
         SELECT routines.specific_schema,
            routines.specific_name,
            'ROUTINE'::text AS text,
            routines.dtd_identifier
           FROM information_schema.routines) x(objschema, objname, objtype, objdtdid)
 SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
    objschema AS object_schema,
    objname AS object_name,
    (objtype)::information_schema.character_data AS object_type,
    objdtdid AS dtd_identifier
   FROM ( SELECT attributes.udt_schema,
            attributes.udt_name,
            'USER-DEFINED TYPE'::text AS text,
            attributes.dtd_identifier
           FROM information_schema.attributes
        UNION ALL
         SELECT columns.table_schema,
            columns.table_name,
            'TABLE'::text AS text,
            columns.dtd_identifier
           FROM information_schema.columns
        UNION ALL
         SELECT domains.domain_schema,
            domains.domain_name,
            'DOMAIN'::text AS text,
            domains.dtd_identifier
           FROM information_schema.domains
        UNION ALL
         SELECT parameters.specific_schema,
            parameters.specific_name,
            'ROUTINE'::text AS text,
            parameters.dtd_identifier
           FROM information_schema.parameters
        UNION ALL
         SELECT routines.specific_schema,
            routines.specific_name,
            'ROUTINE'::text AS text,
            routines.dtd_identifier
           FROM information_schema.routines) x(objschema, objname, objtype, objdtdid)]]></view_script>
			<column name="object_catalog" type="sql_identifier" />
			<column name="object_schema" type="sql_identifier" />
			<column name="object_name" type="sql_identifier" />
			<column name="object_type" type="character_data" />
			<column name="dtd_identifier" type="sql_identifier" />
		</view>
		<view name="domain_constraints" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (rs.nspname)::information_schema.sql_identifier AS constraint_schema,
    (con.conname)::information_schema.sql_identifier AS constraint_name,
    (current_database())::information_schema.sql_identifier AS domain_catalog,
    (n.nspname)::information_schema.sql_identifier AS domain_schema,
    (t.typname)::information_schema.sql_identifier AS domain_name,
    (
        CASE
            WHEN con.condeferrable THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_deferrable,
    (
        CASE
            WHEN con.condeferred THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS initially_deferred
   FROM pg_namespace rs,
    pg_namespace n,
    pg_constraint con,
    pg_type t
  WHERE ((rs.oid = con.connamespace) AND (n.oid = t.typnamespace) AND (t.oid = con.contypid) AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text)))]]></view_script>
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
			<column name="domain_catalog" type="sql_identifier" />
			<column name="domain_schema" type="sql_identifier" />
			<column name="domain_name" type="sql_identifier" />
			<column name="is_deferrable" type="yes_or_no" />
			<column name="initially_deferred" type="yes_or_no" />
		</view>
		<view name="domain_udt_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
    (bt.typname)::information_schema.sql_identifier AS udt_name,
    (current_database())::information_schema.sql_identifier AS domain_catalog,
    (nt.nspname)::information_schema.sql_identifier AS domain_schema,
    (t.typname)::information_schema.sql_identifier AS domain_name
   FROM pg_type t,
    pg_namespace nt,
    pg_type bt,
    pg_namespace nbt
  WHERE ((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid) AND (bt.typnamespace = nbt.oid) AND (t.typtype = 'd'::"char") AND pg_has_role(bt.typowner, 'USAGE'::text))]]></view_script>
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="domain_catalog" type="sql_identifier" />
			<column name="domain_schema" type="sql_identifier" />
			<column name="domain_name" type="sql_identifier" />
		</view>
		<view name="domains" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS domain_catalog,
    (nt.nspname)::information_schema.sql_identifier AS domain_schema,
    (t.typname)::information_schema.sql_identifier AS domain_name,
    (
        CASE
            WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
            WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer)
            ELSE 'USER-DEFINED'::text
        END)::information_schema.character_data AS data_type,
    (information_schema._pg_char_max_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_maximum_length,
    (information_schema._pg_char_octet_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (
        CASE
            WHEN (nco.nspname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS collation_catalog,
    (nco.nspname)::information_schema.sql_identifier AS collation_schema,
    (co.collname)::information_schema.sql_identifier AS collation_name,
    (information_schema._pg_numeric_precision(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_precision,
    (information_schema._pg_numeric_precision_radix(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_precision_radix,
    (information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_scale,
    (information_schema._pg_datetime_precision(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS datetime_precision,
    (information_schema._pg_interval_type(t.typbasetype, t.typtypmod))::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (t.typdefault)::information_schema.character_data AS domain_default,
    (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
    (bt.typname)::information_schema.sql_identifier AS udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    (1)::information_schema.sql_identifier AS dtd_identifier
   FROM (((pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
     JOIN (pg_type bt
     JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typbasetype = bt.oid) AND (t.typtype = 'd'::"char"))))
     LEFT JOIN (pg_collation co
     JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((t.typcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
  WHERE (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text))]]></view_script>
			<column name="domain_catalog" type="sql_identifier" />
			<column name="domain_schema" type="sql_identifier" />
			<column name="domain_name" type="sql_identifier" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="domain_default" type="character_data" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="scope_catalog" type="sql_identifier" />
			<column name="scope_schema" type="sql_identifier" />
			<column name="scope_name" type="sql_identifier" />
			<column name="maximum_cardinality" type="cardinal_number" />
			<column name="dtd_identifier" type="sql_identifier" />
		</view>
		<view name="element_types" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
    (n.nspname)::information_schema.sql_identifier AS object_schema,
    x.objname AS object_name,
    (x.objtype)::information_schema.character_data AS object_type,
    (x.objdtdid)::information_schema.sql_identifier AS collection_type_identifier,
    (
        CASE
            WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(bt.oid, NULL::integer)
            ELSE 'USER-DEFINED'::text
        END)::information_schema.character_data AS data_type,
    (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
    (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (
        CASE
            WHEN (nco.nspname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS collation_catalog,
    (nco.nspname)::information_schema.sql_identifier AS collation_schema,
    (co.collname)::information_schema.sql_identifier AS collation_name,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
    (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
    (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
    (NULL::character varying)::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (NULL::character varying)::information_schema.character_data AS domain_default,
    (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
    (bt.typname)::information_schema.sql_identifier AS udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    (('a'::text || (x.objdtdid)::text))::information_schema.sql_identifier AS dtd_identifier
   FROM pg_namespace n,
    pg_type at,
    pg_namespace nbt,
    pg_type bt,
    (( SELECT c.relnamespace,
            (c.relname)::information_schema.sql_identifier AS relname,
                CASE
                    WHEN (c.relkind = 'c'::"char") THEN 'USER-DEFINED TYPE'::text
                    ELSE 'TABLE'::text
                END AS "case",
            a.attnum,
            a.atttypid,
            a.attcollation
           FROM pg_class c,
            pg_attribute a
          WHERE ((c.oid = a.attrelid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"])) AND (a.attnum > 0) AND (NOT a.attisdropped))
        UNION ALL
         SELECT t.typnamespace,
            (t.typname)::information_schema.sql_identifier AS typname,
            'DOMAIN'::text AS text,
            1,
            t.typbasetype,
            t.typcollation
           FROM pg_type t
          WHERE (t.typtype = 'd'::"char")
        UNION ALL
         SELECT ss.pronamespace,
            (nameconcatoid(ss.proname, ss.oid))::information_schema.sql_identifier AS nameconcatoid,
            'ROUTINE'::text AS text,
            (ss.x).n AS n,
            (ss.x).x AS x,
            0
           FROM ( SELECT p.pronamespace,
                    p.proname,
                    p.oid,
                    information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
                   FROM pg_proc p) ss
        UNION ALL
         SELECT p.pronamespace,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS nameconcatoid,
            'ROUTINE'::text AS text,
            0,
            p.prorettype,
            0
           FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
     LEFT JOIN (pg_collation co
     JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((x.objcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
  WHERE ((n.oid = x.objschema) AND (at.oid = x.objtypeid) AND ((at.typelem <> (0)::oid) AND (at.typlen = '-1'::integer)) AND (at.typelem = bt.oid) AND (nbt.oid = bt.typnamespace) AND ((n.nspname, (x.objname)::name, x.objtype, ((x.objdtdid)::information_schema.sql_identifier)::name) IN ( SELECT data_type_privileges.object_schema,
            data_type_privileges.object_name,
            data_type_privileges.object_type,
            data_type_privileges.dtd_identifier
           FROM information_schema.data_type_privileges)))
 SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
    (n.nspname)::information_schema.sql_identifier AS object_schema,
    x.objname AS object_name,
    (x.objtype)::information_schema.character_data AS object_type,
    (x.objdtdid)::information_schema.sql_identifier AS collection_type_identifier,
    (
        CASE
            WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(bt.oid, NULL::integer)
            ELSE 'USER-DEFINED'::text
        END)::information_schema.character_data AS data_type,
    (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
    (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (
        CASE
            WHEN (nco.nspname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS collation_catalog,
    (nco.nspname)::information_schema.sql_identifier AS collation_schema,
    (co.collname)::information_schema.sql_identifier AS collation_name,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
    (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
    (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
    (NULL::character varying)::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (NULL::character varying)::information_schema.character_data AS domain_default,
    (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nbt.nspname)::information_schema.sql_identifier AS udt_schema,
    (bt.typname)::information_schema.sql_identifier AS udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    (('a'::text || (x.objdtdid)::text))::information_schema.sql_identifier AS dtd_identifier
   FROM pg_namespace n,
    pg_type at,
    pg_namespace nbt,
    pg_type bt,
    (( SELECT c.relnamespace,
            (c.relname)::information_schema.sql_identifier AS relname,
                CASE
                    WHEN (c.relkind = 'c'::"char") THEN 'USER-DEFINED TYPE'::text
                    ELSE 'TABLE'::text
                END AS "case",
            a.attnum,
            a.atttypid,
            a.attcollation
           FROM pg_class c,
            pg_attribute a
          WHERE ((c.oid = a.attrelid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"])) AND (a.attnum > 0) AND (NOT a.attisdropped))
        UNION ALL
         SELECT t.typnamespace,
            (t.typname)::information_schema.sql_identifier AS typname,
            'DOMAIN'::text AS text,
            1,
            t.typbasetype,
            t.typcollation
           FROM pg_type t
          WHERE (t.typtype = 'd'::"char")
        UNION ALL
         SELECT ss.pronamespace,
            (nameconcatoid(ss.proname, ss.oid))::information_schema.sql_identifier AS nameconcatoid,
            'ROUTINE'::text AS text,
            (ss.x).n AS n,
            (ss.x).x AS x,
            0
           FROM ( SELECT p.pronamespace,
                    p.proname,
                    p.oid,
                    information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
                   FROM pg_proc p) ss
        UNION ALL
         SELECT p.pronamespace,
            (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS nameconcatoid,
            'ROUTINE'::text AS text,
            0,
            p.prorettype,
            0
           FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
     LEFT JOIN (pg_collation co
     JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((x.objcollation = co.oid) AND ((nco.nspname <> 'pg_catalog'::name) OR (co.collname <> 'default'::name)))))
  WHERE ((n.oid = x.objschema) AND (at.oid = x.objtypeid) AND ((at.typelem <> (0)::oid) AND (at.typlen = '-1'::integer)) AND (at.typelem = bt.oid) AND (nbt.oid = bt.typnamespace) AND ((n.nspname, (x.objname)::name, x.objtype, ((x.objdtdid)::information_schema.sql_identifier)::name) IN ( SELECT data_type_privileges.object_schema,
            data_type_privileges.object_name,
            data_type_privileges.object_type,
            data_type_privileges.dtd_identifier
           FROM information_schema.data_type_privileges)))]]></view_script>
			<column name="object_catalog" type="sql_identifier" />
			<column name="object_schema" type="sql_identifier" />
			<column name="object_name" type="sql_identifier" />
			<column name="object_type" type="character_data" />
			<column name="collection_type_identifier" type="sql_identifier" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="domain_default" type="character_data" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="scope_catalog" type="sql_identifier" />
			<column name="scope_schema" type="sql_identifier" />
			<column name="scope_name" type="sql_identifier" />
			<column name="maximum_cardinality" type="cardinal_number" />
			<column name="dtd_identifier" type="sql_identifier" />
		</view>
		<view name="enabled_roles" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (rolname)::information_schema.sql_identifier AS role_name
   FROM pg_authid a
  WHERE pg_has_role(oid, 'USAGE'::text)]]></view_script>
			<column name="role_name" type="sql_identifier" />
		</view>
		<view name="foreign_data_wrapper_options" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT foreign_data_wrapper_catalog,
    foreign_data_wrapper_name,
    ((pg_options_to_table(fdwoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(fdwoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_data_wrappers w
 SELECT foreign_data_wrapper_catalog,
    foreign_data_wrapper_name,
    ((pg_options_to_table(fdwoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(fdwoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_data_wrappers w]]></view_script>
			<column name="foreign_data_wrapper_catalog" type="sql_identifier" />
			<column name="foreign_data_wrapper_name" type="sql_identifier" />
			<column name="option_name" type="sql_identifier" />
			<column name="option_value" type="character_data" />
		</view>
		<view name="foreign_data_wrappers" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT foreign_data_wrapper_catalog,
    foreign_data_wrapper_name,
    authorization_identifier,
    (NULL::character varying)::information_schema.character_data AS library_name,
    foreign_data_wrapper_language
   FROM information_schema._pg_foreign_data_wrappers w
 SELECT foreign_data_wrapper_catalog,
    foreign_data_wrapper_name,
    authorization_identifier,
    (NULL::character varying)::information_schema.character_data AS library_name,
    foreign_data_wrapper_language
   FROM information_schema._pg_foreign_data_wrappers w]]></view_script>
			<column name="foreign_data_wrapper_catalog" type="sql_identifier" />
			<column name="foreign_data_wrapper_name" type="sql_identifier" />
			<column name="authorization_identifier" type="sql_identifier" />
			<column name="library_name" type="character_data" />
			<column name="foreign_data_wrapper_language" type="character_data" />
		</view>
		<view name="foreign_server_options" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT foreign_server_catalog,
    foreign_server_name,
    ((pg_options_to_table(srvoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(srvoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_servers s
 SELECT foreign_server_catalog,
    foreign_server_name,
    ((pg_options_to_table(srvoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(srvoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_servers s]]></view_script>
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
			<column name="option_name" type="sql_identifier" />
			<column name="option_value" type="character_data" />
		</view>
		<view name="foreign_servers" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT foreign_server_catalog,
    foreign_server_name,
    foreign_data_wrapper_catalog,
    foreign_data_wrapper_name,
    foreign_server_type,
    foreign_server_version,
    authorization_identifier
   FROM information_schema._pg_foreign_servers
 SELECT foreign_server_catalog,
    foreign_server_name,
    foreign_data_wrapper_catalog,
    foreign_data_wrapper_name,
    foreign_server_type,
    foreign_server_version,
    authorization_identifier
   FROM information_schema._pg_foreign_servers]]></view_script>
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
			<column name="foreign_data_wrapper_catalog" type="sql_identifier" />
			<column name="foreign_data_wrapper_name" type="sql_identifier" />
			<column name="foreign_server_type" type="character_data" />
			<column name="foreign_server_version" type="character_data" />
			<column name="authorization_identifier" type="sql_identifier" />
		</view>
		<view name="foreign_table_options" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT foreign_table_catalog,
    foreign_table_schema,
    foreign_table_name,
    ((pg_options_to_table(ftoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(ftoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_tables t
 SELECT foreign_table_catalog,
    foreign_table_schema,
    foreign_table_name,
    ((pg_options_to_table(ftoptions)).option_name)::information_schema.sql_identifier AS option_name,
    ((pg_options_to_table(ftoptions)).option_value)::information_schema.character_data AS option_value
   FROM information_schema._pg_foreign_tables t]]></view_script>
			<column name="foreign_table_catalog" type="sql_identifier" />
			<column name="foreign_table_schema" type="sql_identifier" />
			<column name="foreign_table_name" type="sql_identifier" />
			<column name="option_name" type="sql_identifier" />
			<column name="option_value" type="character_data" />
		</view>
		<view name="foreign_tables" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT foreign_table_catalog,
    foreign_table_schema,
    foreign_table_name,
    foreign_server_catalog,
    foreign_server_name
   FROM information_schema._pg_foreign_tables
 SELECT foreign_table_catalog,
    foreign_table_schema,
    foreign_table_name,
    foreign_server_catalog,
    foreign_server_name
   FROM information_schema._pg_foreign_tables]]></view_script>
			<column name="foreign_table_catalog" type="sql_identifier" />
			<column name="foreign_table_schema" type="sql_identifier" />
			<column name="foreign_table_name" type="sql_identifier" />
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
		</view>
		<view name="information_schema_catalog_name" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS catalog_name]]></view_script>
			<column name="catalog_name" type="sql_identifier" />
		</view>
		<view name="key_column_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (ss.nc_nspname)::information_schema.sql_identifier AS constraint_schema,
    (ss.conname)::information_schema.sql_identifier AS constraint_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (ss.nr_nspname)::information_schema.sql_identifier AS table_schema,
    (ss.relname)::information_schema.sql_identifier AS table_name,
    (a.attname)::information_schema.sql_identifier AS column_name,
    ((ss.x).n)::information_schema.cardinal_number AS ordinal_position,
    (
        CASE
            WHEN (ss.contype = 'f'::"char") THEN information_schema._pg_index_position(ss.conindid, ss.confkey[(ss.x).n])
            ELSE NULL::integer
        END)::information_schema.cardinal_number AS position_in_unique_constraint
   FROM pg_attribute a,
    ( SELECT r.oid AS roid,
            r.relname,
            r.relowner,
            nc.nspname AS nc_nspname,
            nr.nspname AS nr_nspname,
            c.oid AS coid,
            c.conname,
            c.contype,
            c.conindid,
            c.confkey,
            c.confrelid,
            information_schema._pg_expandarray(c.conkey) AS x
           FROM pg_namespace nr,
            pg_class r,
            pg_namespace nc,
            pg_constraint c
          WHERE ((nr.oid = r.relnamespace) AND (r.oid = c.conrelid) AND (nc.oid = c.connamespace) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)))) ss
  WHERE ((ss.roid = a.attrelid) AND (a.attnum = (ss.x).x) AND (NOT a.attisdropped) AND (pg_has_role(ss.relowner, 'USAGE'::text) OR has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="ordinal_position" type="cardinal_number" />
			<column name="position_in_unique_constraint" type="cardinal_number" />
		</view>
		<view name="parameters" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS specific_catalog,
    (ss.n_nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(ss.proname, ss.p_oid))::information_schema.sql_identifier AS specific_name,
    ((ss.x).n)::information_schema.cardinal_number AS ordinal_position,
    (
        CASE
            WHEN (ss.proargmodes IS NULL) THEN 'IN'::text
            WHEN (ss.proargmodes[(ss.x).n] = 'i'::"char") THEN 'IN'::text
            WHEN (ss.proargmodes[(ss.x).n] = 'o'::"char") THEN 'OUT'::text
            WHEN (ss.proargmodes[(ss.x).n] = 'b'::"char") THEN 'INOUT'::text
            WHEN (ss.proargmodes[(ss.x).n] = 'v'::"char") THEN 'IN'::text
            WHEN (ss.proargmodes[(ss.x).n] = 't'::"char") THEN 'OUT'::text
            ELSE NULL::text
        END)::information_schema.character_data AS parameter_mode,
    ('NO'::character varying)::information_schema.yes_or_no AS is_result,
    ('NO'::character varying)::information_schema.yes_or_no AS as_locator,
    (NULLIF(ss.proargnames[(ss.x).n], ''::text))::information_schema.sql_identifier AS parameter_name,
    (
        CASE
            WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
            WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer)
            ELSE 'USER-DEFINED'::text
        END)::information_schema.character_data AS data_type,
    (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
    (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (NULL::name)::information_schema.sql_identifier AS collation_catalog,
    (NULL::name)::information_schema.sql_identifier AS collation_schema,
    (NULL::name)::information_schema.sql_identifier AS collation_name,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
    (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
    (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
    (NULL::character varying)::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nt.nspname)::information_schema.sql_identifier AS udt_schema,
    (t.typname)::information_schema.sql_identifier AS udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    ((ss.x).n)::information_schema.sql_identifier AS dtd_identifier,
    (
        CASE
            WHEN pg_has_role(ss.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
            ELSE NULL::text
        END)::information_schema.character_data AS parameter_default
   FROM pg_type t,
    pg_namespace nt,
    ( SELECT n.nspname AS n_nspname,
            p.proname,
            p.oid AS p_oid,
            p.proowner,
            p.proargnames,
            p.proargmodes,
            information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
           FROM pg_namespace n,
            pg_proc p
          WHERE ((n.oid = p.pronamespace) AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text)))) ss
  WHERE ((t.oid = (ss.x).x) AND (t.typnamespace = nt.oid))]]></view_script>
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="ordinal_position" type="cardinal_number" />
			<column name="parameter_mode" type="character_data" />
			<column name="is_result" type="yes_or_no" />
			<column name="as_locator" type="yes_or_no" />
			<column name="parameter_name" type="sql_identifier" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="scope_catalog" type="sql_identifier" />
			<column name="scope_schema" type="sql_identifier" />
			<column name="scope_name" type="sql_identifier" />
			<column name="maximum_cardinality" type="cardinal_number" />
			<column name="dtd_identifier" type="sql_identifier" />
			<column name="parameter_default" type="character_data" />
		</view>
		<view name="referential_constraints" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (ncon.nspname)::information_schema.sql_identifier AS constraint_schema,
    (con.conname)::information_schema.sql_identifier AS constraint_name,
    (
        CASE
            WHEN (npkc.nspname IS NULL) THEN NULL::name
            ELSE current_database()
        END)::information_schema.sql_identifier AS unique_constraint_catalog,
    (npkc.nspname)::information_schema.sql_identifier AS unique_constraint_schema,
    (pkc.conname)::information_schema.sql_identifier AS unique_constraint_name,
    (
        CASE con.confmatchtype
            WHEN 'f'::"char" THEN 'FULL'::text
            WHEN 'p'::"char" THEN 'PARTIAL'::text
            WHEN 's'::"char" THEN 'NONE'::text
            ELSE NULL::text
        END)::information_schema.character_data AS match_option,
    (
        CASE con.confupdtype
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET NULL'::text
            WHEN 'd'::"char" THEN 'SET DEFAULT'::text
            WHEN 'r'::"char" THEN 'RESTRICT'::text
            WHEN 'a'::"char" THEN 'NO ACTION'::text
            ELSE NULL::text
        END)::information_schema.character_data AS update_rule,
    (
        CASE con.confdeltype
            WHEN 'c'::"char" THEN 'CASCADE'::text
            WHEN 'n'::"char" THEN 'SET NULL'::text
            WHEN 'd'::"char" THEN 'SET DEFAULT'::text
            WHEN 'r'::"char" THEN 'RESTRICT'::text
            WHEN 'a'::"char" THEN 'NO ACTION'::text
            ELSE NULL::text
        END)::information_schema.character_data AS delete_rule
   FROM ((((((pg_namespace ncon
     JOIN pg_constraint con ON ((ncon.oid = con.connamespace)))
     JOIN pg_class c ON (((con.conrelid = c.oid) AND (con.contype = 'f'::"char"))))
     LEFT JOIN pg_depend d1 ON (((d1.objid = con.oid) AND (d1.classid = ('pg_constraint'::regclass)::oid) AND (d1.refclassid = ('pg_class'::regclass)::oid) AND (d1.refobjsubid = 0))))
     LEFT JOIN pg_depend d2 ON (((d2.refclassid = ('pg_constraint'::regclass)::oid) AND (d2.classid = ('pg_class'::regclass)::oid) AND (d2.objid = d1.refobjid) AND (d2.objsubid = 0) AND (d2.deptype = 'i'::"char"))))
     LEFT JOIN pg_constraint pkc ON (((pkc.oid = d2.refobjid) AND (pkc.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (pkc.conrelid = con.confrelid))))
     LEFT JOIN pg_namespace npkc ON ((pkc.connamespace = npkc.oid)))
  WHERE (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text))]]></view_script>
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
			<column name="unique_constraint_catalog" type="sql_identifier" />
			<column name="unique_constraint_schema" type="sql_identifier" />
			<column name="unique_constraint_name" type="sql_identifier" />
			<column name="match_option" type="character_data" />
			<column name="update_rule" type="character_data" />
			<column name="delete_rule" type="character_data" />
		</view>
		<view name="role_column_grants" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT grantor,
    grantee,
    table_catalog,
    table_schema,
    table_name,
    column_name,
    privilege_type,
    is_grantable
   FROM information_schema.column_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))
 SELECT grantor,
    grantee,
    table_catalog,
    table_schema,
    table_name,
    column_name,
    privilege_type,
    is_grantable
   FROM information_schema.column_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="role_routine_grants" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT grantor,
    grantee,
    specific_catalog,
    specific_schema,
    specific_name,
    routine_catalog,
    routine_schema,
    routine_name,
    privilege_type,
    is_grantable
   FROM information_schema.routine_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))
 SELECT grantor,
    grantee,
    specific_catalog,
    specific_schema,
    specific_name,
    routine_catalog,
    routine_schema,
    routine_name,
    privilege_type,
    is_grantable
   FROM information_schema.routine_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="role_table_grants" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT grantor,
    grantee,
    table_catalog,
    table_schema,
    table_name,
    privilege_type,
    is_grantable,
    with_hierarchy
   FROM information_schema.table_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))
 SELECT grantor,
    grantee,
    table_catalog,
    table_schema,
    table_name,
    privilege_type,
    is_grantable,
    with_hierarchy
   FROM information_schema.table_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
			<column name="with_hierarchy" type="yes_or_no" />
		</view>
		<view name="role_udt_grants" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT grantor,
    grantee,
    udt_catalog,
    udt_schema,
    udt_name,
    privilege_type,
    is_grantable
   FROM information_schema.udt_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))
 SELECT grantor,
    grantee,
    udt_catalog,
    udt_schema,
    udt_name,
    privilege_type,
    is_grantable
   FROM information_schema.udt_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="role_usage_grants" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT grantor,
    grantee,
    object_catalog,
    object_schema,
    object_name,
    object_type,
    privilege_type,
    is_grantable
   FROM information_schema.usage_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))
 SELECT grantor,
    grantee,
    object_catalog,
    object_schema,
    object_name,
    object_type,
    privilege_type,
    is_grantable
   FROM information_schema.usage_privileges
  WHERE (((grantor)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)) OR ((grantee)::name IN ( SELECT enabled_roles.role_name
           FROM information_schema.enabled_roles)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="object_catalog" type="sql_identifier" />
			<column name="object_schema" type="sql_identifier" />
			<column name="object_name" type="sql_identifier" />
			<column name="object_type" type="character_data" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="routine_column_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (current_database())::information_schema.sql_identifier AS routine_catalog,
    (np.nspname)::information_schema.sql_identifier AS routine_schema,
    (p.proname)::information_schema.sql_identifier AS routine_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nt.nspname)::information_schema.sql_identifier AS table_schema,
    (t.relname)::information_schema.sql_identifier AS table_name,
    (a.attname)::information_schema.sql_identifier AS column_name
   FROM pg_namespace np,
    pg_proc p,
    pg_depend d,
    pg_class t,
    pg_namespace nt,
    pg_attribute a
  WHERE ((np.oid = p.pronamespace) AND (p.oid = d.objid) AND (d.classid = ('pg_proc'::regclass)::oid) AND (d.refobjid = t.oid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (t.relnamespace = nt.oid) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (t.oid = a.attrelid) AND (d.refobjsubid = a.attnum) AND pg_has_role(t.relowner, 'USAGE'::text))]]></view_script>
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
		</view>
		<view name="routine_privileges" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS specific_catalog,
    (n.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (current_database())::information_schema.sql_identifier AS routine_catalog,
    (n.nspname)::information_schema.sql_identifier AS routine_schema,
    (p.proname)::information_schema.sql_identifier AS routine_name,
    ('EXECUTE'::character varying)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR p.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pg_proc.oid,
            pg_proc.proname,
            pg_proc.proowner,
            pg_proc.pronamespace,
            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).is_grantable AS is_grantable
           FROM pg_proc) p(oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
    pg_namespace n,
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((p.pronamespace = n.oid) AND (grantee.oid = p.grantee) AND (u_grantor.oid = p.grantor) AND (p.prtype = 'EXECUTE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="routine_routine_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (current_database())::information_schema.sql_identifier AS routine_catalog,
    (np1.nspname)::information_schema.sql_identifier AS routine_schema,
    (nameconcatoid(p1.proname, p1.oid))::information_schema.sql_identifier AS routine_name
   FROM pg_namespace np,
    pg_proc p,
    pg_depend d,
    pg_proc p1,
    pg_namespace np1
  WHERE ((np.oid = p.pronamespace) AND (p.oid = d.objid) AND (d.classid = ('pg_proc'::regclass)::oid) AND (d.refobjid = p1.oid) AND (d.refclassid = ('pg_proc'::regclass)::oid) AND (p1.pronamespace = np1.oid) AND (p.prokind = ANY (ARRAY['f'::"char", 'p'::"char"])) AND (p1.prokind = ANY (ARRAY['f'::"char", 'p'::"char"])) AND pg_has_role(p1.proowner, 'USAGE'::text))]]></view_script>
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
		</view>
		<view name="routine_sequence_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (current_database())::information_schema.sql_identifier AS routine_catalog,
    (np.nspname)::information_schema.sql_identifier AS routine_schema,
    (p.proname)::information_schema.sql_identifier AS routine_name,
    (current_database())::information_schema.sql_identifier AS sequence_catalog,
    (ns.nspname)::information_schema.sql_identifier AS sequence_schema,
    (s.relname)::information_schema.sql_identifier AS sequence_name
   FROM pg_namespace np,
    pg_proc p,
    pg_depend d,
    pg_class s,
    pg_namespace ns
  WHERE ((np.oid = p.pronamespace) AND (p.oid = d.objid) AND (d.classid = ('pg_proc'::regclass)::oid) AND (d.refobjid = s.oid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (s.relnamespace = ns.oid) AND (s.relkind = 'S'::"char") AND pg_has_role(s.relowner, 'USAGE'::text))]]></view_script>
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
			<column name="sequence_catalog" type="sql_identifier" />
			<column name="sequence_schema" type="sql_identifier" />
			<column name="sequence_name" type="sql_identifier" />
		</view>
		<view name="routine_table_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (current_database())::information_schema.sql_identifier AS routine_catalog,
    (np.nspname)::information_schema.sql_identifier AS routine_schema,
    (p.proname)::information_schema.sql_identifier AS routine_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nt.nspname)::information_schema.sql_identifier AS table_schema,
    (t.relname)::information_schema.sql_identifier AS table_name
   FROM pg_namespace np,
    pg_proc p,
    pg_depend d,
    pg_class t,
    pg_namespace nt
  WHERE ((np.oid = p.pronamespace) AND (p.oid = d.objid) AND (d.classid = ('pg_proc'::regclass)::oid) AND (d.refobjid = t.oid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND (t.relnamespace = nt.oid) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND pg_has_role(t.relowner, 'USAGE'::text))]]></view_script>
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
		</view>
		<view name="routines" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS specific_catalog,
    (n.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (current_database())::information_schema.sql_identifier AS routine_catalog,
    (n.nspname)::information_schema.sql_identifier AS routine_schema,
    (p.proname)::information_schema.sql_identifier AS routine_name,
    (
        CASE p.prokind
            WHEN 'f'::"char" THEN 'FUNCTION'::text
            WHEN 'p'::"char" THEN 'PROCEDURE'::text
            ELSE NULL::text
        END)::information_schema.character_data AS routine_type,
    (NULL::name)::information_schema.sql_identifier AS module_catalog,
    (NULL::name)::information_schema.sql_identifier AS module_schema,
    (NULL::name)::information_schema.sql_identifier AS module_name,
    (NULL::name)::information_schema.sql_identifier AS udt_catalog,
    (NULL::name)::information_schema.sql_identifier AS udt_schema,
    (NULL::name)::information_schema.sql_identifier AS udt_name,
    (
        CASE
            WHEN (p.prokind = 'p'::"char") THEN NULL::text
            WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
            WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer)
            ELSE 'USER-DEFINED'::text
        END)::information_schema.character_data AS data_type,
    (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
    (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (NULL::name)::information_schema.sql_identifier AS collation_catalog,
    (NULL::name)::information_schema.sql_identifier AS collation_schema,
    (NULL::name)::information_schema.sql_identifier AS collation_name,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
    (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
    (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
    (NULL::character varying)::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (
        CASE
            WHEN (nt.nspname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS type_udt_catalog,
    (nt.nspname)::information_schema.sql_identifier AS type_udt_schema,
    (t.typname)::information_schema.sql_identifier AS type_udt_name,
    (NULL::name)::information_schema.sql_identifier AS scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS scope_schema,
    (NULL::name)::information_schema.sql_identifier AS scope_name,
    (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality,
    (
        CASE
            WHEN (p.prokind <> 'p'::"char") THEN 0
            ELSE NULL::integer
        END)::information_schema.sql_identifier AS dtd_identifier,
    (
        CASE
            WHEN (l.lanname = 'sql'::name) THEN 'SQL'::text
            ELSE 'EXTERNAL'::text
        END)::information_schema.character_data AS routine_body,
    (
        CASE
            WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc
            ELSE NULL::text
        END)::information_schema.character_data AS routine_definition,
    (
        CASE
            WHEN (l.lanname = 'c'::name) THEN p.prosrc
            ELSE NULL::text
        END)::information_schema.character_data AS external_name,
    (upper((l.lanname)::text))::information_schema.character_data AS external_language,
    ('GENERAL'::character varying)::information_schema.character_data AS parameter_style,
    (
        CASE
            WHEN (p.provolatile = 'i'::"char") THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_deterministic,
    ('MODIFIES'::character varying)::information_schema.character_data AS sql_data_access,
    (
        CASE
            WHEN (p.prokind <> 'p'::"char") THEN
            CASE
                WHEN p.proisstrict THEN 'YES'::text
                ELSE 'NO'::text
            END
            ELSE NULL::text
        END)::information_schema.yes_or_no AS is_null_call,
    (NULL::character varying)::information_schema.character_data AS sql_path,
    ('YES'::character varying)::information_schema.yes_or_no AS schema_level_routine,
    (0)::information_schema.cardinal_number AS max_dynamic_result_sets,
    (NULL::character varying)::information_schema.yes_or_no AS is_user_defined_cast,
    (NULL::character varying)::information_schema.yes_or_no AS is_implicitly_invocable,
    (
        CASE
            WHEN p.prosecdef THEN 'DEFINER'::text
            ELSE 'INVOKER'::text
        END)::information_schema.character_data AS security_type,
    (NULL::name)::information_schema.sql_identifier AS to_sql_specific_catalog,
    (NULL::name)::information_schema.sql_identifier AS to_sql_specific_schema,
    (NULL::name)::information_schema.sql_identifier AS to_sql_specific_name,
    ('NO'::character varying)::information_schema.yes_or_no AS as_locator,
    (NULL::timestamp with time zone)::information_schema.time_stamp AS created,
    (NULL::timestamp with time zone)::information_schema.time_stamp AS last_altered,
    (NULL::character varying)::information_schema.yes_or_no AS new_savepoint_level,
    ('NO'::character varying)::information_schema.yes_or_no AS is_udt_dependent,
    (NULL::character varying)::information_schema.character_data AS result_cast_from_data_type,
    (NULL::character varying)::information_schema.yes_or_no AS result_cast_as_locator,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_char_max_length,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_char_octet_length,
    (NULL::name)::information_schema.sql_identifier AS result_cast_char_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS result_cast_char_set_schema,
    (NULL::name)::information_schema.sql_identifier AS result_cast_char_set_name,
    (NULL::name)::information_schema.sql_identifier AS result_cast_collation_catalog,
    (NULL::name)::information_schema.sql_identifier AS result_cast_collation_schema,
    (NULL::name)::information_schema.sql_identifier AS result_cast_collation_name,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_precision,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_precision_radix,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_scale,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_datetime_precision,
    (NULL::character varying)::information_schema.character_data AS result_cast_interval_type,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_interval_precision,
    (NULL::name)::information_schema.sql_identifier AS result_cast_type_udt_catalog,
    (NULL::name)::information_schema.sql_identifier AS result_cast_type_udt_schema,
    (NULL::name)::information_schema.sql_identifier AS result_cast_type_udt_name,
    (NULL::name)::information_schema.sql_identifier AS result_cast_scope_catalog,
    (NULL::name)::information_schema.sql_identifier AS result_cast_scope_schema,
    (NULL::name)::information_schema.sql_identifier AS result_cast_scope_name,
    (NULL::integer)::information_schema.cardinal_number AS result_cast_maximum_cardinality,
    (NULL::name)::information_schema.sql_identifier AS result_cast_dtd_identifier
   FROM (((pg_namespace n
     JOIN pg_proc p ON ((n.oid = p.pronamespace)))
     JOIN pg_language l ON ((p.prolang = l.oid)))
     LEFT JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON (((p.prorettype = t.oid) AND (p.prokind <> 'p'::"char"))))
  WHERE (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text))]]></view_script>
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="routine_catalog" type="sql_identifier" />
			<column name="routine_schema" type="sql_identifier" />
			<column name="routine_name" type="sql_identifier" />
			<column name="routine_type" type="character_data" />
			<column name="module_catalog" type="sql_identifier" />
			<column name="module_schema" type="sql_identifier" />
			<column name="module_name" type="sql_identifier" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="type_udt_catalog" type="sql_identifier" />
			<column name="type_udt_schema" type="sql_identifier" />
			<column name="type_udt_name" type="sql_identifier" />
			<column name="scope_catalog" type="sql_identifier" />
			<column name="scope_schema" type="sql_identifier" />
			<column name="scope_name" type="sql_identifier" />
			<column name="maximum_cardinality" type="cardinal_number" />
			<column name="dtd_identifier" type="sql_identifier" />
			<column name="routine_body" type="character_data" />
			<column name="routine_definition" type="character_data" />
			<column name="external_name" type="character_data" />
			<column name="external_language" type="character_data" />
			<column name="parameter_style" type="character_data" />
			<column name="is_deterministic" type="yes_or_no" />
			<column name="sql_data_access" type="character_data" />
			<column name="is_null_call" type="yes_or_no" />
			<column name="sql_path" type="character_data" />
			<column name="schema_level_routine" type="yes_or_no" />
			<column name="max_dynamic_result_sets" type="cardinal_number" />
			<column name="is_user_defined_cast" type="yes_or_no" />
			<column name="is_implicitly_invocable" type="yes_or_no" />
			<column name="security_type" type="character_data" />
			<column name="to_sql_specific_catalog" type="sql_identifier" />
			<column name="to_sql_specific_schema" type="sql_identifier" />
			<column name="to_sql_specific_name" type="sql_identifier" />
			<column name="as_locator" type="yes_or_no" />
			<column name="created" type="time_stamp" />
			<column name="last_altered" type="time_stamp" />
			<column name="new_savepoint_level" type="yes_or_no" />
			<column name="is_udt_dependent" type="yes_or_no" />
			<column name="result_cast_from_data_type" type="character_data" />
			<column name="result_cast_as_locator" type="yes_or_no" />
			<column name="result_cast_char_max_length" type="cardinal_number" />
			<column name="result_cast_char_octet_length" type="cardinal_number" />
			<column name="result_cast_char_set_catalog" type="sql_identifier" />
			<column name="result_cast_char_set_schema" type="sql_identifier" />
			<column name="result_cast_char_set_name" type="sql_identifier" />
			<column name="result_cast_collation_catalog" type="sql_identifier" />
			<column name="result_cast_collation_schema" type="sql_identifier" />
			<column name="result_cast_collation_name" type="sql_identifier" />
			<column name="result_cast_numeric_precision" type="cardinal_number" />
			<column name="result_cast_numeric_precision_radix" type="cardinal_number" />
			<column name="result_cast_numeric_scale" type="cardinal_number" />
			<column name="result_cast_datetime_precision" type="cardinal_number" />
			<column name="result_cast_interval_type" type="character_data" />
			<column name="result_cast_interval_precision" type="cardinal_number" />
			<column name="result_cast_type_udt_catalog" type="sql_identifier" />
			<column name="result_cast_type_udt_schema" type="sql_identifier" />
			<column name="result_cast_type_udt_name" type="sql_identifier" />
			<column name="result_cast_scope_catalog" type="sql_identifier" />
			<column name="result_cast_scope_schema" type="sql_identifier" />
			<column name="result_cast_scope_name" type="sql_identifier" />
			<column name="result_cast_maximum_cardinality" type="cardinal_number" />
			<column name="result_cast_dtd_identifier" type="sql_identifier" />
		</view>
		<view name="schemata" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS catalog_name,
    (n.nspname)::information_schema.sql_identifier AS schema_name,
    (u.rolname)::information_schema.sql_identifier AS schema_owner,
    (NULL::name)::information_schema.sql_identifier AS default_character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS default_character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS default_character_set_name,
    (NULL::character varying)::information_schema.character_data AS sql_path
   FROM pg_namespace n,
    pg_authid u
  WHERE ((n.nspowner = u.oid) AND (pg_has_role(n.nspowner, 'USAGE'::text) OR has_schema_privilege(n.oid, 'CREATE, USAGE'::text)))]]></view_script>
			<column name="catalog_name" type="sql_identifier" />
			<column name="schema_name" type="sql_identifier" />
			<column name="schema_owner" type="sql_identifier" />
			<column name="default_character_set_catalog" type="sql_identifier" />
			<column name="default_character_set_schema" type="sql_identifier" />
			<column name="default_character_set_name" type="sql_identifier" />
			<column name="sql_path" type="character_data" />
		</view>
		<view name="sequences" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS sequence_catalog,
    (nc.nspname)::information_schema.sql_identifier AS sequence_schema,
    (c.relname)::information_schema.sql_identifier AS sequence_name,
    (format_type(s.seqtypid, NULL::integer))::information_schema.character_data AS data_type,
    (information_schema._pg_numeric_precision(s.seqtypid, '-1'::integer))::information_schema.cardinal_number AS numeric_precision,
    (2)::information_schema.cardinal_number AS numeric_precision_radix,
    (0)::information_schema.cardinal_number AS numeric_scale,
    (s.seqstart)::information_schema.character_data AS start_value,
    (s.seqmin)::information_schema.character_data AS minimum_value,
    (s.seqmax)::information_schema.character_data AS maximum_value,
    (s.seqincrement)::information_schema.character_data AS increment,
    (
        CASE
            WHEN s.seqcycle THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS cycle_option
   FROM pg_namespace nc,
    pg_class c,
    pg_sequence s
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT (EXISTS ( SELECT 1
           FROM pg_depend
          WHERE ((pg_depend.classid = ('pg_class'::regclass)::oid) AND (pg_depend.objid = c.oid) AND (pg_depend.deptype = 'i'::"char"))))) AND (NOT pg_is_other_temp_schema(nc.oid)) AND (c.oid = s.seqrelid) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE'::text)))]]></view_script>
			<column name="sequence_catalog" type="sql_identifier" />
			<column name="sequence_schema" type="sql_identifier" />
			<column name="sequence_name" type="sql_identifier" />
			<column name="data_type" type="character_data" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="start_value" type="character_data" />
			<column name="minimum_value" type="character_data" />
			<column name="maximum_value" type="character_data" />
			<column name="increment" type="character_data" />
			<column name="cycle_option" type="yes_or_no" />
		</view>
		<view name="table_constraints" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (nc.nspname)::information_schema.sql_identifier AS constraint_schema,
    (c.conname)::information_schema.sql_identifier AS constraint_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nr.nspname)::information_schema.sql_identifier AS table_schema,
    (r.relname)::information_schema.sql_identifier AS table_name,
    (
        CASE c.contype
            WHEN 'c'::"char" THEN 'CHECK'::text
            WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
            WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
            WHEN 'u'::"char" THEN 'UNIQUE'::text
            ELSE NULL::text
        END)::information_schema.character_data AS constraint_type,
    (
        CASE
            WHEN c.condeferrable THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_deferrable,
    (
        CASE
            WHEN c.condeferred THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS initially_deferred,
    ('YES'::character varying)::information_schema.yes_or_no AS enforced,
    (
        CASE
            WHEN (c.contype = 'u'::"char") THEN
            CASE
                WHEN ( SELECT (NOT pg_index.indnullsnotdistinct)
                   FROM pg_index
                  WHERE (pg_index.indexrelid = c.conindid)) THEN 'YES'::text
                ELSE 'NO'::text
            END
            ELSE NULL::text
        END)::information_schema.yes_or_no AS nulls_distinct
   FROM pg_namespace nc,
    pg_namespace nr,
    pg_constraint c,
    pg_class r
  WHERE ((nc.oid = c.connamespace) AND (nr.oid = r.relnamespace) AND (c.conrelid = r.oid) AND (c.contype <> ALL (ARRAY['t'::"char", 'x'::"char"])) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)))
UNION ALL
 SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
    (nr.nspname)::information_schema.sql_identifier AS constraint_schema,
    (((((((nr.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text))::information_schema.sql_identifier AS constraint_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nr.nspname)::information_schema.sql_identifier AS table_schema,
    (r.relname)::information_schema.sql_identifier AS table_name,
    ('CHECK'::character varying)::information_schema.character_data AS constraint_type,
    ('NO'::character varying)::information_schema.yes_or_no AS is_deferrable,
    ('NO'::character varying)::information_schema.yes_or_no AS initially_deferred,
    ('YES'::character varying)::information_schema.yes_or_no AS enforced,
    (NULL::character varying)::information_schema.yes_or_no AS nulls_distinct
   FROM pg_namespace nr,
    pg_class r,
    pg_attribute a
  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND a.attnotnull AND (a.attnum > 0) AND (NOT a.attisdropped) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="constraint_catalog" type="sql_identifier" />
			<column name="constraint_schema" type="sql_identifier" />
			<column name="constraint_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="constraint_type" type="character_data" />
			<column name="is_deferrable" type="yes_or_no" />
			<column name="initially_deferred" type="yes_or_no" />
			<column name="enforced" type="yes_or_no" />
			<column name="nulls_distinct" type="yes_or_no" />
		</view>
		<view name="table_privileges" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (c.prtype)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable,
    (
        CASE
            WHEN (c.prtype = 'SELECT'::text) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS with_hierarchy
   FROM ( SELECT pg_class.oid,
            pg_class.relname,
            pg_class.relnamespace,
            pg_class.relkind,
            pg_class.relowner,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).is_grantable AS is_grantable
           FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
    pg_namespace nc,
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text])) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
			<column name="with_hierarchy" type="yes_or_no" />
		</view>
		<view name="tables" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (
        CASE
            WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY'::text
            WHEN (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) THEN 'BASE TABLE'::text
            WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
            WHEN (c.relkind = 'f'::"char") THEN 'FOREIGN'::text
            ELSE NULL::text
        END)::information_schema.character_data AS table_type,
    (NULL::name)::information_schema.sql_identifier AS self_referencing_column_name,
    (NULL::character varying)::information_schema.character_data AS reference_generation,
    (
        CASE
            WHEN (t.typname IS NOT NULL) THEN current_database()
            ELSE NULL::name
        END)::information_schema.sql_identifier AS user_defined_type_catalog,
    (nt.nspname)::information_schema.sql_identifier AS user_defined_type_schema,
    (t.typname)::information_schema.sql_identifier AS user_defined_type_name,
    (
        CASE
            WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND ((pg_relation_is_updatable((c.oid)::regclass, false) & 8) = 8))) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_insertable_into,
    (
        CASE
            WHEN (t.typname IS NOT NULL) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_typed,
    (NULL::character varying)::information_schema.character_data AS commit_action
   FROM ((pg_namespace nc
     JOIN pg_class c ON ((nc.oid = c.relnamespace)))
     LEFT JOIN (pg_type t
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="table_type" type="character_data" />
			<column name="self_referencing_column_name" type="sql_identifier" />
			<column name="reference_generation" type="character_data" />
			<column name="user_defined_type_catalog" type="sql_identifier" />
			<column name="user_defined_type_schema" type="sql_identifier" />
			<column name="user_defined_type_name" type="sql_identifier" />
			<column name="is_insertable_into" type="yes_or_no" />
			<column name="is_typed" type="yes_or_no" />
			<column name="commit_action" type="character_data" />
		</view>
		<view name="transforms" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nt.nspname)::information_schema.sql_identifier AS udt_schema,
    (t.typname)::information_schema.sql_identifier AS udt_name,
    (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (l.lanname)::information_schema.sql_identifier AS group_name,
    ('FROM SQL'::character varying)::information_schema.character_data AS transform_type
   FROM (((((pg_type t
     JOIN pg_transform x ON ((t.oid = x.trftype)))
     JOIN pg_language l ON ((x.trflang = l.oid)))
     JOIN pg_proc p ON (((x.trffromsql)::oid = p.oid)))
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
     JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
UNION
 SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
    (nt.nspname)::information_schema.sql_identifier AS udt_schema,
    (t.typname)::information_schema.sql_identifier AS udt_name,
    (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name,
    (l.lanname)::information_schema.sql_identifier AS group_name,
    ('TO SQL'::character varying)::information_schema.character_data AS transform_type
   FROM (((((pg_type t
     JOIN pg_transform x ON ((t.oid = x.trftype)))
     JOIN pg_language l ON ((x.trflang = l.oid)))
     JOIN pg_proc p ON (((x.trftosql)::oid = p.oid)))
     JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
     JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
  ORDER BY 1, 2, 3, 7, 8]]></view_script>
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
			<column name="group_name" type="sql_identifier" />
			<column name="transform_type" type="character_data" />
		</view>
		<view name="triggered_update_columns" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog,
    (n.nspname)::information_schema.sql_identifier AS trigger_schema,
    (t.tgname)::information_schema.sql_identifier AS trigger_name,
    (current_database())::information_schema.sql_identifier AS event_object_catalog,
    (n.nspname)::information_schema.sql_identifier AS event_object_schema,
    (c.relname)::information_schema.sql_identifier AS event_object_table,
    (a.attname)::information_schema.sql_identifier AS event_object_column
   FROM pg_namespace n,
    pg_class c,
    pg_trigger t,
    ( SELECT ta0.tgoid,
            (ta0.tgat).x AS tgattnum,
            (ta0.tgat).n AS tgattpos
           FROM ( SELECT pg_trigger.oid AS tgoid,
                    information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
                   FROM pg_trigger) ta0) ta,
    pg_attribute a
  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (t.oid = ta.tgoid) AND ((a.attrelid = t.tgrelid) AND (a.attnum = ta.tgattnum)) AND (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="trigger_catalog" type="sql_identifier" />
			<column name="trigger_schema" type="sql_identifier" />
			<column name="trigger_name" type="sql_identifier" />
			<column name="event_object_catalog" type="sql_identifier" />
			<column name="event_object_schema" type="sql_identifier" />
			<column name="event_object_table" type="sql_identifier" />
			<column name="event_object_column" type="sql_identifier" />
		</view>
		<view name="triggers" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog,
    (n.nspname)::information_schema.sql_identifier AS trigger_schema,
    (t.tgname)::information_schema.sql_identifier AS trigger_name,
    (em.text)::information_schema.character_data AS event_manipulation,
    (current_database())::information_schema.sql_identifier AS event_object_catalog,
    (n.nspname)::information_schema.sql_identifier AS event_object_schema,
    (c.relname)::information_schema.sql_identifier AS event_object_table,
    (rank() OVER (PARTITION BY (n.nspname)::information_schema.sql_identifier, (c.relname)::information_schema.sql_identifier, em.num, ((t.tgtype)::integer & 1), ((t.tgtype)::integer & 66) ORDER BY t.tgname))::information_schema.cardinal_number AS action_order,
    (
        CASE
            WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(t.oid), '.{35,} WHEN \((.+)\) EXECUTE FUNCTION'::text))[1]
            ELSE NULL::text
        END)::information_schema.character_data AS action_condition,
    (SUBSTRING(pg_get_triggerdef(t.oid) FROM (POSITION(('EXECUTE FUNCTION'::text) IN (SUBSTRING(pg_get_triggerdef(t.oid) FROM 48))) + 47)))::information_schema.character_data AS action_statement,
    (
        CASE ((t.tgtype)::integer & 1)
            WHEN 1 THEN 'ROW'::text
            ELSE 'STATEMENT'::text
        END)::information_schema.character_data AS action_orientation,
    (
        CASE ((t.tgtype)::integer & 66)
            WHEN 2 THEN 'BEFORE'::text
            WHEN 64 THEN 'INSTEAD OF'::text
            ELSE 'AFTER'::text
        END)::information_schema.character_data AS action_timing,
    (t.tgoldtable)::information_schema.sql_identifier AS action_reference_old_table,
    (t.tgnewtable)::information_schema.sql_identifier AS action_reference_new_table,
    (NULL::name)::information_schema.sql_identifier AS action_reference_old_row,
    (NULL::name)::information_schema.sql_identifier AS action_reference_new_row,
    (NULL::timestamp with time zone)::information_schema.time_stamp AS created
   FROM pg_namespace n,
    pg_class c,
    pg_trigger t,
    ( VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text)
  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (((t.tgtype)::integer & em.num) <> 0) AND (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="trigger_catalog" type="sql_identifier" />
			<column name="trigger_schema" type="sql_identifier" />
			<column name="trigger_name" type="sql_identifier" />
			<column name="event_manipulation" type="character_data" />
			<column name="event_object_catalog" type="sql_identifier" />
			<column name="event_object_schema" type="sql_identifier" />
			<column name="event_object_table" type="sql_identifier" />
			<column name="action_order" type="cardinal_number" />
			<column name="action_condition" type="character_data" />
			<column name="action_statement" type="character_data" />
			<column name="action_orientation" type="character_data" />
			<column name="action_timing" type="character_data" />
			<column name="action_reference_old_table" type="sql_identifier" />
			<column name="action_reference_new_table" type="sql_identifier" />
			<column name="action_reference_old_row" type="sql_identifier" />
			<column name="action_reference_new_row" type="sql_identifier" />
			<column name="created" type="time_stamp" />
		</view>
		<view name="udt_privileges" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS udt_catalog,
    (n.nspname)::information_schema.sql_identifier AS udt_schema,
    (t.typname)::information_schema.sql_identifier AS udt_name,
    ('TYPE USAGE'::character varying)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pg_type.oid,
            pg_type.typname,
            pg_type.typnamespace,
            pg_type.typtype,
            pg_type.typowner,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).is_grantable AS is_grantable
           FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
    pg_namespace n,
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'c'::"char") AND (t.grantee = grantee.oid) AND (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="udt_catalog" type="sql_identifier" />
			<column name="udt_schema" type="sql_identifier" />
			<column name="udt_name" type="sql_identifier" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="usage_privileges" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (u.rolname)::information_schema.sql_identifier AS grantor,
    ('PUBLIC'::name)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS object_catalog,
    (n.nspname)::information_schema.sql_identifier AS object_schema,
    (c.collname)::information_schema.sql_identifier AS object_name,
    ('COLLATION'::character varying)::information_schema.character_data AS object_type,
    ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
    ('NO'::character varying)::information_schema.yes_or_no AS is_grantable
   FROM pg_authid u,
    pg_namespace n,
    pg_collation c
  WHERE ((u.oid = c.collowner) AND (c.collnamespace = n.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])))
UNION ALL
 SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS object_catalog,
    (n.nspname)::information_schema.sql_identifier AS object_schema,
    (t.typname)::information_schema.sql_identifier AS object_name,
    ('DOMAIN'::character varying)::information_schema.character_data AS object_type,
    ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pg_type.oid,
            pg_type.typname,
            pg_type.typnamespace,
            pg_type.typtype,
            pg_type.typowner,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).is_grantable AS is_grantable
           FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
    pg_namespace n,
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'd'::"char") AND (t.grantee = grantee.oid) AND (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))
UNION ALL
 SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS object_catalog,
    (''::name)::information_schema.sql_identifier AS object_schema,
    (fdw.fdwname)::information_schema.sql_identifier AS object_name,
    ('FOREIGN DATA WRAPPER'::character varying)::information_schema.character_data AS object_type,
    ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR fdw.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pg_foreign_data_wrapper.fdwname,
            pg_foreign_data_wrapper.fdwowner,
            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl, acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).is_grantable AS is_grantable
           FROM pg_foreign_data_wrapper) fdw(fdwname, fdwowner, grantor, grantee, prtype, grantable),
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((u_grantor.oid = fdw.grantor) AND (grantee.oid = fdw.grantee) AND (fdw.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))
UNION ALL
 SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS object_catalog,
    (''::name)::information_schema.sql_identifier AS object_schema,
    (srv.srvname)::information_schema.sql_identifier AS object_name,
    ('FOREIGN SERVER'::character varying)::information_schema.character_data AS object_type,
    ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR srv.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pg_foreign_server.srvname,
            pg_foreign_server.srvowner,
            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_foreign_server.srvacl, acldefault('S'::"char", pg_foreign_server.srvowner)))).is_grantable AS is_grantable
           FROM pg_foreign_server) srv(srvname, srvowner, grantor, grantee, prtype, grantable),
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((u_grantor.oid = srv.grantor) AND (grantee.oid = srv.grantee) AND (srv.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))
UNION ALL
 SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor,
    (grantee.rolname)::information_schema.sql_identifier AS grantee,
    (current_database())::information_schema.sql_identifier AS object_catalog,
    (n.nspname)::information_schema.sql_identifier AS object_schema,
    (c.relname)::information_schema.sql_identifier AS object_name,
    ('SEQUENCE'::character varying)::information_schema.character_data AS object_type,
    ('USAGE'::character varying)::information_schema.character_data AS privilege_type,
    (
        CASE
            WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_grantable
   FROM ( SELECT pg_class.oid,
            pg_class.relname,
            pg_class.relnamespace,
            pg_class.relkind,
            pg_class.relowner,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantee AS grantee,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).privilege_type AS privilege_type,
            (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).is_grantable AS is_grantable
           FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
    pg_namespace n,
    pg_authid u_grantor,
    ( SELECT pg_authid.oid,
            pg_authid.rolname
           FROM pg_authid
        UNION ALL
         SELECT (0)::oid AS oid,
            'PUBLIC'::name) grantee(oid, rolname)
  WHERE ((c.relnamespace = n.oid) AND (c.relkind = 'S'::"char") AND (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = 'USAGE'::text) AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR (grantee.rolname = 'PUBLIC'::name)))]]></view_script>
			<column name="grantor" type="sql_identifier" />
			<column name="grantee" type="sql_identifier" />
			<column name="object_catalog" type="sql_identifier" />
			<column name="object_schema" type="sql_identifier" />
			<column name="object_name" type="sql_identifier" />
			<column name="object_type" type="character_data" />
			<column name="privilege_type" type="character_data" />
			<column name="is_grantable" type="yes_or_no" />
		</view>
		<view name="user_defined_types" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS user_defined_type_catalog,
    (n.nspname)::information_schema.sql_identifier AS user_defined_type_schema,
    (c.relname)::information_schema.sql_identifier AS user_defined_type_name,
    ('STRUCTURED'::character varying)::information_schema.character_data AS user_defined_type_category,
    ('YES'::character varying)::information_schema.yes_or_no AS is_instantiable,
    (NULL::character varying)::information_schema.yes_or_no AS is_final,
    (NULL::character varying)::information_schema.character_data AS ordering_form,
    (NULL::character varying)::information_schema.character_data AS ordering_category,
    (NULL::name)::information_schema.sql_identifier AS ordering_routine_catalog,
    (NULL::name)::information_schema.sql_identifier AS ordering_routine_schema,
    (NULL::name)::information_schema.sql_identifier AS ordering_routine_name,
    (NULL::character varying)::information_schema.character_data AS reference_type,
    (NULL::character varying)::information_schema.character_data AS data_type,
    (NULL::integer)::information_schema.cardinal_number AS character_maximum_length,
    (NULL::integer)::information_schema.cardinal_number AS character_octet_length,
    (NULL::name)::information_schema.sql_identifier AS character_set_catalog,
    (NULL::name)::information_schema.sql_identifier AS character_set_schema,
    (NULL::name)::information_schema.sql_identifier AS character_set_name,
    (NULL::name)::information_schema.sql_identifier AS collation_catalog,
    (NULL::name)::information_schema.sql_identifier AS collation_schema,
    (NULL::name)::information_schema.sql_identifier AS collation_name,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision,
    (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix,
    (NULL::integer)::information_schema.cardinal_number AS numeric_scale,
    (NULL::integer)::information_schema.cardinal_number AS datetime_precision,
    (NULL::character varying)::information_schema.character_data AS interval_type,
    (NULL::integer)::information_schema.cardinal_number AS interval_precision,
    (NULL::name)::information_schema.sql_identifier AS source_dtd_identifier,
    (NULL::name)::information_schema.sql_identifier AS ref_dtd_identifier
   FROM pg_namespace n,
    pg_class c,
    pg_type t
  WHERE ((n.oid = c.relnamespace) AND (t.typrelid = c.oid) AND (c.relkind = 'c'::"char") AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text)))]]></view_script>
			<column name="user_defined_type_catalog" type="sql_identifier" />
			<column name="user_defined_type_schema" type="sql_identifier" />
			<column name="user_defined_type_name" type="sql_identifier" />
			<column name="user_defined_type_category" type="character_data" />
			<column name="is_instantiable" type="yes_or_no" />
			<column name="is_final" type="yes_or_no" />
			<column name="ordering_form" type="character_data" />
			<column name="ordering_category" type="character_data" />
			<column name="ordering_routine_catalog" type="sql_identifier" />
			<column name="ordering_routine_schema" type="sql_identifier" />
			<column name="ordering_routine_name" type="sql_identifier" />
			<column name="reference_type" type="character_data" />
			<column name="data_type" type="character_data" />
			<column name="character_maximum_length" type="cardinal_number" />
			<column name="character_octet_length" type="cardinal_number" />
			<column name="character_set_catalog" type="sql_identifier" />
			<column name="character_set_schema" type="sql_identifier" />
			<column name="character_set_name" type="sql_identifier" />
			<column name="collation_catalog" type="sql_identifier" />
			<column name="collation_schema" type="sql_identifier" />
			<column name="collation_name" type="sql_identifier" />
			<column name="numeric_precision" type="cardinal_number" />
			<column name="numeric_precision_radix" type="cardinal_number" />
			<column name="numeric_scale" type="cardinal_number" />
			<column name="datetime_precision" type="cardinal_number" />
			<column name="interval_type" type="character_data" />
			<column name="interval_precision" type="cardinal_number" />
			<column name="source_dtd_identifier" type="sql_identifier" />
			<column name="ref_dtd_identifier" type="sql_identifier" />
		</view>
		<view name="user_mapping_options" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT um.authorization_identifier,
    um.foreign_server_catalog,
    um.foreign_server_name,
    (opts.option_name)::information_schema.sql_identifier AS option_name,
    (
        CASE
            WHEN (((um.umuser <> (0)::oid) AND ((um.authorization_identifier)::name = CURRENT_USER)) OR ((um.umuser = (0)::oid) AND pg_has_role((um.srvowner)::name, 'USAGE'::text)) OR ( SELECT pg_authid.rolsuper
               FROM pg_authid
              WHERE (pg_authid.rolname = CURRENT_USER))) THEN opts.option_value
            ELSE NULL::text
        END)::information_schema.character_data AS option_value
   FROM information_schema._pg_user_mappings um,
    LATERAL pg_options_to_table(um.umoptions) opts(option_name, option_value)
 SELECT um.authorization_identifier,
    um.foreign_server_catalog,
    um.foreign_server_name,
    (opts.option_name)::information_schema.sql_identifier AS option_name,
    (
        CASE
            WHEN (((um.umuser <> (0)::oid) AND ((um.authorization_identifier)::name = CURRENT_USER)) OR ((um.umuser = (0)::oid) AND pg_has_role((um.srvowner)::name, 'USAGE'::text)) OR ( SELECT pg_authid.rolsuper
               FROM pg_authid
              WHERE (pg_authid.rolname = CURRENT_USER))) THEN opts.option_value
            ELSE NULL::text
        END)::information_schema.character_data AS option_value
   FROM information_schema._pg_user_mappings um,
    LATERAL pg_options_to_table(um.umoptions) opts(option_name, option_value)]]></view_script>
			<column name="authorization_identifier" type="sql_identifier" />
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
			<column name="option_name" type="sql_identifier" />
			<column name="option_value" type="character_data" />
		</view>
		<view name="user_mappings" >
			<view_script><![CDATA[CREATE OR REPLACE VIEW ${view} AS SELECT authorization_identifier,
    foreign_server_catalog,
    foreign_server_name
   FROM information_schema._pg_user_mappings
 SELECT authorization_identifier,
    foreign_server_catalog,
    foreign_server_name
   FROM information_schema._pg_user_mappings]]></view_script>
			<column name="authorization_identifier" type="sql_identifier" />
			<column name="foreign_server_catalog" type="sql_identifier" />
			<column name="foreign_server_name" type="sql_identifier" />
		</view>
		<view name="view_column_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog,
    (nv.nspname)::information_schema.sql_identifier AS view_schema,
    (v.relname)::information_schema.sql_identifier AS view_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nt.nspname)::information_schema.sql_identifier AS table_schema,
    (t.relname)::information_schema.sql_identifier AS table_name,
    (a.attname)::information_schema.sql_identifier AS column_name
   FROM pg_namespace nv,
    pg_class v,
    pg_depend dv,
    pg_depend dt,
    pg_class t,
    pg_namespace nt,
    pg_attribute a
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND (dv.deptype = 'i'::"char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND (dt.classid = ('pg_rewrite'::regclass)::oid) AND (dt.refclassid = ('pg_class'::regclass)::oid) AND (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (t.oid = a.attrelid) AND (dt.refobjsubid = a.attnum) AND pg_has_role(t.relowner, 'USAGE'::text))]]></view_script>
			<column name="view_catalog" type="sql_identifier" />
			<column name="view_schema" type="sql_identifier" />
			<column name="view_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="column_name" type="sql_identifier" />
		</view>
		<view name="view_routine_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nv.nspname)::information_schema.sql_identifier AS table_schema,
    (v.relname)::information_schema.sql_identifier AS table_name,
    (current_database())::information_schema.sql_identifier AS specific_catalog,
    (np.nspname)::information_schema.sql_identifier AS specific_schema,
    (nameconcatoid(p.proname, p.oid))::information_schema.sql_identifier AS specific_name
   FROM pg_namespace nv,
    pg_class v,
    pg_depend dv,
    pg_depend dp,
    pg_proc p,
    pg_namespace np
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND (dv.deptype = 'i'::"char") AND (dv.objid = dp.objid) AND (dp.classid = ('pg_rewrite'::regclass)::oid) AND (dp.refclassid = ('pg_proc'::regclass)::oid) AND (dp.refobjid = p.oid) AND (p.pronamespace = np.oid) AND pg_has_role(p.proowner, 'USAGE'::text))]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="specific_catalog" type="sql_identifier" />
			<column name="specific_schema" type="sql_identifier" />
			<column name="specific_name" type="sql_identifier" />
		</view>
		<view name="view_table_usage" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog,
    (nv.nspname)::information_schema.sql_identifier AS view_schema,
    (v.relname)::information_schema.sql_identifier AS view_name,
    (current_database())::information_schema.sql_identifier AS table_catalog,
    (nt.nspname)::information_schema.sql_identifier AS table_schema,
    (t.relname)::information_schema.sql_identifier AS table_name
   FROM pg_namespace nv,
    pg_class v,
    pg_depend dv,
    pg_depend dt,
    pg_class t,
    pg_namespace nt
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND (dv.deptype = 'i'::"char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND (dt.classid = ('pg_rewrite'::regclass)::oid) AND (dt.refclassid = ('pg_class'::regclass)::oid) AND (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND pg_has_role(t.relowner, 'USAGE'::text))]]></view_script>
			<column name="view_catalog" type="sql_identifier" />
			<column name="view_schema" type="sql_identifier" />
			<column name="view_name" type="sql_identifier" />
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
		</view>
		<view name="views" >
			<view_script><![CDATA[CREATE VIEW ${nameWithSchemaName} AS SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
    (nc.nspname)::information_schema.sql_identifier AS table_schema,
    (c.relname)::information_schema.sql_identifier AS table_name,
    (
        CASE
            WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid)
            ELSE NULL::text
        END)::information_schema.character_data AS view_definition,
    (
        CASE
            WHEN ('check_option=cascaded'::text = ANY (c.reloptions)) THEN 'CASCADED'::text
            WHEN ('check_option=local'::text = ANY (c.reloptions)) THEN 'LOCAL'::text
            ELSE 'NONE'::text
        END)::information_schema.character_data AS check_option,
    (
        CASE
            WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_updatable,
    (
        CASE
            WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 8) = 8) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_insertable_into,
    (
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM pg_trigger
              WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 81) = 81)))) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_trigger_updatable,
    (
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM pg_trigger
              WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 73) = 73)))) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_trigger_deletable,
    (
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM pg_trigger
              WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 69) = 69)))) THEN 'YES'::text
            ELSE 'NO'::text
        END)::information_schema.yes_or_no AS is_trigger_insertable_into
   FROM pg_namespace nc,
    pg_class c
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)))]]></view_script>
			<column name="table_catalog" type="sql_identifier" />
			<column name="table_schema" type="sql_identifier" />
			<column name="table_name" type="sql_identifier" />
			<column name="view_definition" type="character_data" />
			<column name="check_option" type="character_data" />
			<column name="is_updatable" type="yes_or_no" />
			<column name="is_insertable_into" type="yes_or_no" />
			<column name="is_trigger_updatable" type="yes_or_no" />
			<column name="is_trigger_deletable" type="yes_or_no" />
			<column name="is_trigger_insertable_into" type="yes_or_no" />
		</view>
		<function name="_pg_char_max_length" id="Function-1d45" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_char_max_length(typid oid, typmod integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (typmod = '-1'::integer) THEN NULL::integer WHEN (typid = ANY (ARRAY[(1042)::oid, (1043)::oid])) THEN (typmod - 4) WHEN (typid = ANY (ARRAY[(1560)::oid, (1562)::oid])) THEN typmod ELSE NULL::integer END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="typmod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_char_octet_length" id="Function-790" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_char_octet_length(typid oid, typmod integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (typid = ANY (ARRAY[(25)::oid, (1042)::oid, (1043)::oid])) THEN CASE WHEN (typmod = '-1'::integer) THEN (((2)::double precision ^ (30)::double precision))::integer ELSE (information_schema._pg_char_max_length(typid, typmod) * pg_encoding_max_length((SELECT pg_database.encoding FROM pg_database WHERE (pg_database.datname = current_database())))) END ELSE NULL::integer END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="typmod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_datetime_precision" id="Function-221f" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_datetime_precision(typid oid, typmod integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (typid = (1082)::oid) THEN 0 WHEN (typid = ANY (ARRAY[(1083)::oid, (1114)::oid, (1184)::oid, (1266)::oid])) THEN CASE WHEN (typmod < 0) THEN 6 ELSE typmod END WHEN (typid = (1186)::oid) THEN CASE WHEN ((typmod < 0) OR ((typmod & 65535) = 65535)) THEN 6 ELSE (typmod & 65535) END ELSE NULL::integer END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="typmod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_expandarray" id="Function-26c2" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_expandarray(anyarray, OUT x anyelement, OUT n integer)
 RETURNS SETOF record
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
AS $function$select $1[s],
        s operator(pg_catalog.-) pg_catalog.array_lower($1,1) operator(pg_catalog.+) 1
        from pg_catalog.generate_series(pg_catalog.array_lower($1,1),
                                        pg_catalog.array_upper($1,1),
                                        1) as g(s)$function$
;]]></string>
			<input_param jt="-1" type="anyarray" inOut="1" />
			<input_param name="x" jt="-1" type="anyelement" inOut="3" />
			<input_param name="n" jt="-1" type="integer" inOut="3" />
		</function>
		<function name="_pg_index_position" id="Function-1454" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_index_position(oid, smallint)
 RETURNS integer
 LANGUAGE sql
 STABLE STRICT
BEGIN ATOMIC
 SELECT (ss.a).n AS n
    FROM ( SELECT information_schema._pg_expandarray(pg_index.indkey) AS a
            FROM pg_index
           WHERE (pg_index.indexrelid = $1)) ss
   WHERE ((ss.a).x = $2);
END
;]]></string>
			<input_param jt="-1" type="oid" inOut="1" />
			<input_param jt="-1" type="smallint" inOut="1" />
		</function>
		<function name="_pg_interval_type" id="Function-134e" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_interval_type(typid oid, mod integer)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (typid = (1186)::oid) THEN upper(SUBSTRING(format_type(typid, mod) SIMILAR 'interval[()0-9]* #"%#"'::text ESCAPE '#'::text)) ELSE NULL::text END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="mod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_numeric_precision" id="Function-1608" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_numeric_precision(typid oid, typmod integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE typid WHEN 21 THEN 16 WHEN 23 THEN 32 WHEN 20 THEN 64 WHEN 1700 THEN CASE WHEN (typmod = '-1'::integer) THEN NULL::integer ELSE (((typmod - 4) >> 16) & 65535) END WHEN 700 THEN 24 WHEN 701 THEN 53 ELSE NULL::integer END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="typmod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_numeric_precision_radix" id="Function-12b8" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_numeric_precision_radix(typid oid, typmod integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (typid = ANY (ARRAY[(21)::oid, (23)::oid, (20)::oid, (700)::oid, (701)::oid])) THEN 2 WHEN (typid = (1700)::oid) THEN 10 ELSE NULL::integer END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="typmod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_numeric_scale" id="Function-1bce" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_numeric_scale(typid oid, typmod integer)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (typid = ANY (ARRAY[(21)::oid, (23)::oid, (20)::oid])) THEN 0 WHEN (typid = (1700)::oid) THEN CASE WHEN (typmod = '-1'::integer) THEN NULL::integer ELSE ((typmod - 4) & 65535) END ELSE NULL::integer END
;]]></string>
			<input_param name="typid" jt="-1" type="oid" inOut="1" />
			<input_param name="typmod" jt="-1" type="integer" inOut="1" />
		</function>
		<function name="_pg_truetypid" id="Function-11b1" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_truetypid(pg_attribute, pg_type)
 RETURNS oid
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (($2).typtype = 'd'::"char") THEN ($2).typbasetype ELSE ($1).atttypid END
;]]></string>
			<input_param jt="-1" type="pg_attribute" inOut="1" />
			<input_param jt="-1" type="pg_type" inOut="1" />
		</function>
		<function name="_pg_truetypmod" id="Function-1a6f" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION information_schema._pg_truetypmod(pg_attribute, pg_type)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE PARALLEL SAFE STRICT
RETURN CASE WHEN (($2).typtype = 'd'::"char") THEN ($2).typtypmod ELSE ($1).atttypmod END
;]]></string>
			<input_param jt="-1" type="pg_attribute" inOut="1" />
			<input_param jt="-1" type="pg_type" inOut="1" />
		</function>
	</schema>
	<schema name="telegram" >
		<udt name="chat_member_status" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('chatMemberStatusCreator','chatMemberStatusAdministrator','chatMemberStatusMember','chatMemberStatusRestricted','chatMemberStatusLeft','chatMemberStatusBanned');]]></udt_script>
		</udt>
		<udt name="message_sender_type" udt_java_type="12" udt_precision="NONE" >
			<udt_script><![CDATA[CREATE TYPE ${name} AS ENUM ('messageSenderUser','messageSenderChat');]]></udt_script>
		</udt>
		<table name="message" row_count="16231" spec="" >
			<column name="api_id" type="integer" length="32" jt="4" mandatory="y" />
			<column name="chat_id" type="bigint" length="64" jt="-5" mandatory="y" />
			<column name="id" type="bigint" length="64" jt="-5" mandatory="y" />
			<column name="sender_type" type="message_sender_type" jt="12" mandatory="y" />
			<column name="sender_id" type="bigint" length="64" jt="-5" mandatory="y" />
			<column name="date" type="timestamp" jt="93" />
			<column name="edit_date" type="timestamp" jt="93" />
			<column name="is_pinned" type="boolean" jt="16" />
			<column name="is_channel_post" type="boolean" jt="16" />
			<column name="reply_to_chat_id" type="bigint" length="64" jt="-5" />
			<column name="reply_to_message_id" type="bigint" length="64" jt="-5" />
			<column name="message_thread_id" type="bigint" length="64" jt="-5" />
			<column name="media_album_id" type="bigint" length="64" jt="-5" />
			<column name="view_count" type="integer" length="32" jt="4" />
			<column name="forward_count" type="integer" length="32" jt="4" />
			<column name="content_type" type="varchar" length="50" jt="12" mandatory="y" />
			<column name="content" type="jsonb" jt="2000" mandatory="y" />
			<index name="message_pkey" unique="PRIMARY_KEY" >
				<column name="api_id" />
				<column name="chat_id" />
				<column name="id" />
			</index>
			<fk name="message_api_id_chat_id_fkey" to_schema="telegram" to_table="supergroup" options="" >
				<fk_column name="api_id" pk="api_id" />
				<fk_column name="chat_id" pk="chat_id" />
			</fk>
		</table>
		<table name="supergroup" row_count="139" spec="" >
			<column name="id" type="bigint" length="64" jt="-5" mandatory="y" />
			<column name="api_id" type="integer" length="32" jt="4" mandatory="y" />
			<column name="chat_id" type="bigint" length="64" jt="-5" />
			<column name="title" type="varchar" jt="12" />
			<column name="profile_photo" type="varchar" jt="12" />
			<column name="member_count" type="integer" length="32" jt="4" />
			<column name="username" type="varchar" jt="12" />
			<column name="description" type="text" jt="12" />
			<column name="member_status" type="chat_member_status" jt="12" />
			<column name="has_linked_chat" type="boolean" jt="16" />
			<column name="linked_chat_id" type="bigint" length="64" jt="-5" />
			<column name="is_channel" type="boolean" jt="16" />
			<column name="is_broadcast_group" type="boolean" jt="16" />
			<column name="is_verified" type="boolean" jt="16" />
			<column name="is_scam" type="boolean" jt="16" />
			<column name="is_fake" type="boolean" jt="16" />
			<column name="is_blocked" type="boolean" jt="16" />
			<index name="supergroup_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
				<column name="api_id" />
			</index>
			<index name="unique_api_chat_id" unique="UNIQUE_KEY" >
				<column name="api_id" />
				<column name="chat_id" />
			</index>
			<index name="idx_supergroup_api_chat" unique="NORMAL" spec="USING  btree" >
				<column name="api_id" />
				<column name="chat_id" />
			</index>
		</table>
	</schema>
	<layout name="Layout" id="Layout-1f1f" joined_routing="y" show_column_type="y" show_page_borders="y" show_relation="columns" >
		<entity schema="core" name="confirmation_token" color="3986C1" x="624" y="48" />
		<entity schema="core" name="locality" color="3986C1" x="352" y="368" />
		<entity schema="core" name="mapping_info" color="3986C1" x="48" y="48" />
		<entity schema="telegram" name="message" color="3986C1" x="672" y="624" />
		<entity schema="telegram" name="supergroup" color="3986C1" x="176" y="624" />
		<entity schema="core" name="user_account" color="3986C1" x="672" y="256" />
		<entity schema="core" name="wiretap" color="3986C1" x="352" y="160" />
	</layout>
	<layout name="Layout_001" id="Layout-f8c" show_column_type="y" show_relation="columns" >
		<entity schema="core" name="confirmation_token" color="3986C1" x="656" y="592" />
		<entity schema="core" name="locality" color="3986C1" x="112" y="320" />
		<entity schema="core" name="mapping_info" color="3986C1" x="48" y="128" />
		<entity schema="telegram" name="message" color="3986C1" x="1072" y="208" />
		<entity schema="telegram" name="supergroup" color="3986C1" x="672" y="240" />
		<entity schema="core" name="user_account" color="3986C1" x="384" y="352" />
		<entity schema="core" name="wiretap" color="3986C1" x="336" y="48" />
	</layout>
	<layout name="Layout_002" id="Layout-6f6" joined_routing="y" show_column_type="y" show_relation="no_text" >
		<entity schema="core" name="confirmation_token" color="3986C1" x="592" y="800" />
		<entity schema="core" name="locality" color="3986C1" x="48" y="688" />
		<entity schema="core" name="mapping_info" color="3986C1" x="64" y="432" />
		<entity schema="telegram" name="message" color="3986C1" x="48" y="48" />
		<entity schema="telegram" name="supergroup" color="3986C1" x="384" y="48" />
		<entity schema="core" name="user_account" color="3986C1" x="320" y="720" />
		<entity schema="core" name="wiretap" color="3986C1" x="368" y="432" />
	</layout>
	<layout name="core" id="Layout-1849" show_relation="columns" >
		<entity schema="core" name="confirmation_token" color="BED3F4" x="800" y="224" />
		<entity schema="core" name="locality" color="BED3F4" x="272" y="496" />
		<entity schema="core" name="mapping_info" color="BED3F4" x="48" y="496" />
		<entity schema="core" name="user_account" color="BED3F4" x="576" y="224" />
		<entity schema="core" name="wiretap" color="BED3F4" x="272" y="224" />
		<callout x="272" y="80" pointer="Round" >
			<comment><![CDATA[This is a layout. You can create multiple layouts with the same or different tables. 
Double-click the table headers to edit.]]></comment>
		</callout>
		<group name="wiretap" color="ECF0F7" >
			<entity schema="core" name="wiretap" />
			<entity schema="core" name="user_account" />
			<entity schema="core" name="confirmation_token" />
			<entity schema="core" name="locality" />
			<entity schema="core" name="mapping_info" />
		</group>
	</layout>
	<layout name="information_schema" id="Layout-219f" confirmed="y" show_relation="columns" >
		<entity schema="information_schema" name="_pg_foreign_data_wrappers" color="BED3F4" x="688" y="2080" />
		<entity schema="information_schema" name="_pg_foreign_servers" color="C7F4BE" x="2624" y="3840" />
		<entity schema="information_schema" name="_pg_foreign_table_columns" color="C7F4BE" x="3200" y="3840" />
		<entity schema="information_schema" name="_pg_foreign_tables" color="C7F4BE" x="2928" y="3840" />
		<entity schema="information_schema" name="_pg_user_mappings" color="C7F4BE" x="2352" y="3840" />
		<entity schema="information_schema" name="administrable_role_authorizations" color="BED3F4" x="1008" y="2080" />
		<entity schema="information_schema" name="applicable_roles" color="BED3F4" x="1008" y="2336" />
		<entity schema="information_schema" name="attributes" color="BED3F4" x="688" y="2336" />
		<entity schema="information_schema" name="character_sets" color="BED3F4" x="416" y="2336" />
		<entity schema="information_schema" name="check_constraint_routine_usage" color="BED3F4" x="368" y="2096" />
		<entity schema="information_schema" name="check_constraints" color="BED3F4" x="1344" y="80" />
		<entity schema="information_schema" name="collation_character_set_applicability" color="BED3F4" x="352" y="1840" />
		<entity schema="information_schema" name="collations" color="BED3F4" x="1824" y="1872" />
		<entity schema="information_schema" name="column_column_usage" color="BED3F4" x="688" y="1856" />
		<entity schema="information_schema" name="column_domain_usage" color="BED3F4" x="1056" y="1168" />
		<entity schema="information_schema" name="column_options" color="BED3F4" x="832" y="1184" />
		<entity schema="information_schema" name="column_privileges" color="BED3F4" x="1584" y="288" />
		<entity schema="information_schema" name="column_udt_usage" color="BED3F4" x="1808" y="288" />
		<entity schema="information_schema" name="columns" color="BED3F4" x="1280" y="288" />
		<entity schema="information_schema" name="constraint_column_usage" color="BED3F4" x="1008" y="1824" />
		<entity schema="information_schema" name="constraint_table_usage" color="BED3F4" x="1808" y="560" />
		<entity schema="information_schema" name="data_type_privileges" color="BED3F4" x="1344" y="2080" />
		<entity schema="information_schema" name="domain_constraints" color="BED3F4" x="1344" y="1808" />
		<entity schema="information_schema" name="domain_udt_usage" color="BED3F4" x="352" y="464" />
		<entity schema="information_schema" name="domains" color="BED3F4" x="48" y="464" />
		<entity schema="information_schema" name="element_types" color="BED3F4" x="1232" y="2336" />
		<entity schema="information_schema" name="enabled_roles" color="BED3F4" x="1008" y="2528" />
		<entity schema="information_schema" name="foreign_data_wrapper_options" color="BED3F4" x="992" y="2976" />
		<entity schema="information_schema" name="foreign_data_wrappers" color="BEBEF4" x="2928" y="80" />
		<entity schema="information_schema" name="foreign_server_options" color="BEBEF4" x="2352" y="80" />
		<entity schema="information_schema" name="foreign_servers" color="BEBEF4" x="2624" y="80" />
		<entity schema="information_schema" name="foreign_table_options" color="BEBEF4" x="2928" y="336" />
		<entity schema="information_schema" name="foreign_tables" color="BEBEF4" x="3200" y="336" />
		<entity schema="information_schema" name="information_schema_catalog_name" color="BED3F4" x="656" y="2976" />
		<entity schema="information_schema" name="key_column_usage" color="BED3F4" x="384" y="2688" />
		<entity schema="information_schema" name="parameters" color="BED3F4" x="64" y="2336" />
		<entity schema="information_schema" name="referential_constraints" color="BED3F4" x="64" y="1792" />
		<entity schema="information_schema" name="role_column_grants" color="BED3F4" x="352" y="1568" />
		<entity schema="information_schema" name="role_routine_grants" color="BED3F4" x="112" y="1264" />
		<entity schema="information_schema" name="role_table_grants" color="BED3F4" x="352" y="1296" />
		<entity schema="information_schema" name="role_udt_grants" color="BED3F4" x="352" y="1040" />
		<entity schema="information_schema" name="role_usage_grants" color="BED3F4" x="576" y="1040" />
		<entity schema="information_schema" name="routine_column_usage" color="BED3F4" x="688" y="1536" />
		<entity schema="information_schema" name="routine_privileges" color="BED3F4" x="1600" y="800" />
		<entity schema="information_schema" name="routine_routine_usage" color="BED3F4" x="2064" y="1104" />
		<entity schema="information_schema" name="routine_sequence_usage" color="BED3F4" x="1312" y="1136" />
		<entity schema="information_schema" name="routine_table_usage" color="BED3F4" x="1584" y="1136" />
		<entity schema="information_schema" name="routines" color="BED3F4" x="1824" y="1104" >
			<column name="specific_catalog" />
			<column name="specific_schema" />
			<column name="specific_name" />
			<column name="routine_catalog" />
			<column name="routine_schema" />
			<column name="routine_name" />
			<column name="routine_type" />
			<column name="module_catalog" />
			<column name="module_schema" />
			<column name="module_name" />
			<column name="udt_catalog" />
		</entity>
		<entity schema="information_schema" name="schemata" color="BED3F4" x="48" y="2080" />
		<entity schema="information_schema" name="sequences" color="BED3F4" x="1008" y="1488" />
		<entity schema="information_schema" name="sql_features" color="BED3F4" x="1584" y="2080" />
		<entity schema="information_schema" name="sql_implementation_info" color="BED3F4" x="1824" y="2080" />
		<entity schema="information_schema" name="sql_parts" color="BED3F4" x="1824" y="2336" />
		<entity schema="information_schema" name="sql_sizing" color="BED3F4" x="2048" y="2336" />
		<entity schema="information_schema" name="table_constraints" color="BED3F4" x="1584" y="1760" />
		<entity schema="information_schema" name="table_privileges" color="BED3F4" x="1904" y="1424" />
		<entity schema="information_schema" name="tables" color="BED3F4" x="1584" y="1424" />
		<entity schema="information_schema" name="transforms" color="BED3F4" x="1344" y="1536" />
		<entity schema="information_schema" name="triggered_update_columns" color="BED3F4" x="1536" y="2336" />
		<entity schema="information_schema" name="triggers" color="BED3F4" x="1824" y="2592" />
		<entity schema="information_schema" name="udt_privileges" color="BED3F4" x="1536" y="2688" />
		<entity schema="information_schema" name="usage_privileges" color="BED3F4" x="1536" y="2944" />
		<entity schema="information_schema" name="user_defined_types" color="BED3F4" x="992" y="3184" />
		<entity schema="information_schema" name="user_mapping_options" color="F4DDBE" x="2352" y="3568" />
		<entity schema="information_schema" name="user_mappings" color="F4DDBE" x="2624" y="3568" />
		<entity schema="information_schema" name="view_column_usage" color="BED3F4" x="1296" y="2976" />
		<entity schema="information_schema" name="view_routine_usage" color="BED3F4" x="1296" y="3232" />
		<entity schema="information_schema" name="view_table_usage" color="BED3F4" x="1296" y="3472" />
		<entity schema="information_schema" name="views" color="BED3F4" x="1536" y="3232" />
		<group name="_pg_foreign_data_wrappers" color="ECF0F7" >
			<entity schema="information_schema" name="_pg_foreign_data_wrappers" />
			<entity schema="information_schema" name="administrable_role_authorizations" />
			<entity schema="information_schema" name="applicable_roles" />
			<entity schema="information_schema" name="attributes" />
			<entity schema="information_schema" name="character_sets" />
			<entity schema="information_schema" name="check_constraint_routine_usage" />
			<entity schema="information_schema" name="collation_character_set_applicability" />
			<entity schema="information_schema" name="column_column_usage" />
			<entity schema="information_schema" name="constraint_column_usage" />
			<entity schema="information_schema" name="data_type_privileges" />
			<entity schema="information_schema" name="domain_constraints" />
			<entity schema="information_schema" name="element_types" />
			<entity schema="information_schema" name="enabled_roles" />
			<entity schema="information_schema" name="foreign_data_wrapper_options" />
			<entity schema="information_schema" name="information_schema_catalog_name" />
			<entity schema="information_schema" name="key_column_usage" />
			<entity schema="information_schema" name="parameters" />
			<entity schema="information_schema" name="referential_constraints" />
			<entity schema="information_schema" name="role_column_grants" />
			<entity schema="information_schema" name="routine_column_usage" />
			<entity schema="information_schema" name="schemata" />
			<entity schema="information_schema" name="sequences" />
			<entity schema="information_schema" name="sql_features" />
			<entity schema="information_schema" name="table_constraints" />
			<entity schema="information_schema" name="transforms" />
			<entity schema="information_schema" name="triggered_update_columns" />
			<entity schema="information_schema" name="udt_privileges" />
			<entity schema="information_schema" name="usage_privileges" />
			<entity schema="information_schema" name="user_defined_types" />
			<entity schema="information_schema" name="view_column_usage" />
			<entity schema="information_schema" name="sql_implementation_info" />
			<entity schema="information_schema" name="sql_parts" />
			<entity schema="information_schema" name="collations" />
			<entity schema="information_schema" name="views" />
			<entity schema="information_schema" name="role_routine_grants" />
			<entity schema="information_schema" name="role_table_grants" />
			<entity schema="information_schema" name="view_routine_usage" />
			<entity schema="information_schema" name="view_table_usage" />
			<entity schema="information_schema" name="triggers" />
			<entity schema="information_schema" name="role_udt_grants" />
			<entity schema="information_schema" name="tables" />
			<entity schema="information_schema" name="role_usage_grants" />
			<entity schema="information_schema" name="table_privileges" />
			<entity schema="information_schema" name="routine_sequence_usage" />
			<entity schema="information_schema" name="routine_table_usage" />
			<entity schema="information_schema" name="column_domain_usage" />
			<entity schema="information_schema" name="column_options" />
			<entity schema="information_schema" name="routines" />
			<entity schema="information_schema" name="columns" />
			<entity schema="information_schema" name="domains" />
			<entity schema="information_schema" name="routine_routine_usage" />
			<entity schema="information_schema" name="domain_udt_usage" />
			<entity schema="information_schema" name="routine_privileges" />
			<entity schema="information_schema" name="sql_sizing" />
			<entity schema="information_schema" name="column_privileges" />
			<entity schema="information_schema" name="column_udt_usage" />
			<entity schema="information_schema" name="constraint_table_usage" />
			<entity schema="information_schema" name="check_constraints" />
		</group>
		<group name="foreign_server_options" color="ECECF7" >
			<entity schema="information_schema" name="foreign_server_options" />
			<entity schema="information_schema" name="foreign_servers" />
			<entity schema="information_schema" name="foreign_data_wrappers" />
			<entity schema="information_schema" name="foreign_table_options" />
			<entity schema="information_schema" name="foreign_tables" />
		</group>
		<group name="user_mapping_options" color="F7F2EC" >
			<entity schema="information_schema" name="user_mapping_options" />
			<entity schema="information_schema" name="user_mappings" />
		</group>
		<group name="_pg_user_mappings" color="EEF7EC" >
			<entity schema="information_schema" name="_pg_user_mappings" />
			<entity schema="information_schema" name="_pg_foreign_servers" />
			<entity schema="information_schema" name="_pg_foreign_tables" />
			<entity schema="information_schema" name="_pg_foreign_table_columns" />
		</group>
	</layout>
	<layout name="telegram" id="Layout-2534" show_relation="columns" >
		<entity schema="telegram" name="message" color="BED3F4" x="304" y="80" />
		<entity schema="telegram" name="supergroup" color="BED3F4" x="48" y="80" />
		<group name="supergroup" color="ECF0F7" >
			<entity schema="telegram" name="supergroup" />
			<entity schema="telegram" name="message" />
		</group>
	</layout>
	<layout name="~Layout with Sample Tools" id="Layout-21c9" show_column_type="y" show_relation="columns" >
		<entity schema="core" name="confirmation_token" color="BED3F4" x="976" y="48" />
		<entity schema="core" name="locality" color="BED3F4" x="320" y="320" />
		<entity schema="core" name="mapping_info" color="BED3F4" x="48" y="320" />
		<entity schema="core" name="user_account" color="BED3F4" x="656" y="48" />
		<entity schema="core" name="wiretap" color="BED3F4" x="320" y="48" />
		<script name="SQL Editor" id="Editor-1a45" language="SQL" >
			<string><![CDATA[SELECT
	id, user_account_id, locality_id, telegram_supergroup_id, telegram_supergroup_api_id, primary_interlink, status, 
	created_at
FROM
	core.wiretap p;]]></string>
		</script>
		<browser id="Browse-74a" name="Relational Data Explorer" confirm_updates="y" >
			<browse_table schema="core" entity="wiretap" x="20" y="20" width="270" height="-60" >
				<browse_table schema="core" entity="mapping_info" fk="mapping_info_wiretap_id_fkey" x="310" y="20" width="500" height="350" />
			</browse_table>
		</browser>
		<query id="Query-1e67" name="Query Builder" >
			<query_table schema="core" name="wiretap" alias="w" x="48" y="48" >
				<column name="id" />
				<column name="user_account_id" />
				<column name="locality_id" />
				<column name="telegram_supergroup_id" />
				<column name="telegram_supergroup_api_id" />
				<column name="primary_interlink" />
				<column name="status" />
				<column name="created_at" />
				<query_table schema="core" name="mapping_info" alias="mi" x="352" y="48" fk="mapping_info_wiretap_id_fkey" type="Inner Join" >
					<column name="id" />
					<column name="wiretap_id" />
					<column name="title" />
					<column name="member_count" />
					<column name="username" />
					<column name="description" />
					<column name="is_channel" />
				</query_table>
			</query_table>
		</query>
		<form name="Report" id="Report-1a67" template="Page" css="container-fluid" view="frame" >
			<var name="samplePageNumber" type="4" value="0" mandatory="n" />
			<var name="sampleRecordsPerPage" type="4" value="100" mandatory="n" />
			<body name="Body" template="Grid" max_records="100" pos="0,0,0,0,f,f" layout="{{-2,-2,-2,-2,-1},{-2,-2,-2}}" generate_path="y" scroll="n" html="n" header_rows="0" footer_rows="0" >
				<cell type="label" name="Wiretap Data" template="H3" pos="0,0,1,0,l,c" />
				<tableview name="sample" template="Table" max_records="100" css="sortable table table-striped table-sm table-hover" pos="0,1,4,1,f,f" layout="{{-2,-2,-2,-2,-2,-2,-2,-2,-2},{-2,-2}}" generate_path="y" scroll="n" html="n" header_rows="1" footer_rows="0" >
					<form_script type="DataSource" language="SQL" >
						<var name="id" type="4" />
						<var name="user_account_id" type="4" />
						<var name="locality_id" type="4" />
						<var name="telegram_supergroup_id" type="-5" />
						<var name="telegram_supergroup_api_id" type="4" />
						<var name="primary_interlink" type="-1" />
						<var name="status" type="-1" />
						<var name="created_at" type="93" />
						<script ><![CDATA[SELECT * FROM core.wiretap]]></script>
					</form_script>
					<cell type="label" name="id" template="Plain" pos="0,0,0,0,c,c" />
					<cell type="label" name="user_account_id" template="Plain" pos="1,0,1,0,c,c" />
					<cell type="label" name="locality_id" template="Plain" pos="2,0,2,0,c,c" />
					<cell type="label" name="telegram_supergroup_id" template="Plain" pos="3,0,3,0,c,c" />
					<cell type="label" name="telegram_supergroup_api_id" template="Plain" pos="4,0,4,0,c,c" />
					<cell type="label" name="primary_interlink" template="Plain" pos="5,0,5,0,c,c" />
					<cell type="label" name="status" template="Plain" pos="6,0,6,0,c,c" />
					<cell type="label" name="created_at" template="Plain" pos="7,0,7,0,c,c" />
					<cell type="label" name="${id}" template="Plain" pos="0,1,0,1,l,c" />
					<cell type="label" name="${user_account_id}" template="Plain" pos="1,1,1,1,l,c" />
					<cell type="label" name="${locality_id}" template="Plain" pos="2,1,2,1,l,c" />
					<cell type="label" name="${telegram_supergroup_id}" template="Plain" pos="3,1,3,1,l,c" />
					<cell type="label" name="${telegram_supergroup_api_id}" template="Plain" pos="4,1,4,1,l,c" />
					<cell type="label" name="${primary_interlink}" template="Plain" pos="5,1,5,1,l,c" />
					<cell type="label" name="${status}" template="Plain" pos="6,1,6,1,l,c" />
					<cell type="label" name="${created_at}" template="Plain" pos="7,1,7,1,l,c" />
					<cell type="button" name="More" template="Plain" css="btn btn-sm btn-secondary" pos="8,1,8,1,c,c" ref_id="Report-1a67" />
				</tableview>
				<cell type="href" name="" template="Plain" disabled="${samplePageNumber&lt;1}" pos="0,2,0,2,l,c" glyph="bi-chevron_double_left" ref_id="Report-1a67" >
					<var name="samplePageNumber" value="0" />
				</cell>
				<cell type="href" name="" template="Plain" disabled="${samplePageNumber&lt;1}" pos="1,2,1,2,l,c" glyph="bi-chevron_left" ref_id="Report-1a67" >
					<var name="samplePageNumber" value="${Math.max(0,samplePageNumber-1)}" />
				</cell>
				<cell type="label" name="Page ${samplePageNumber+1}" template="Plain" pos="2,2,2,2,l,c" />
				<cell type="href" name="" template="Plain" disabled="${!sampleHasNextPage}" pos="3,2,3,2,l,c" glyph="bi-chevron_right" ref_id="Report-1a67" >
					<var name="samplePageNumber" value="${( samplePageNumber+1 )}" />
				</cell>
			</body>
		</form>
	</layout>
</project>